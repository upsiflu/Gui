#!/usr/bin/env node
// src/Compile.ts
var fs7 = require("fs");

// src/ElmJson.ts
var fs2 = require("fs");
var Decode2 = require("tiny-decoders");

// src/Helpers.ts
var import_tiny_decoders = require("tiny-decoders");
function join(array3, separator) {
  return array3.join(separator);
}
function split(string6, splitter) {
  return string6.split(splitter);
}
function getSetSingleton(set) {
  return set.size === 1 ? Array.from(set)[0] : void 0;
}
var CLEAR = "\x1B[2J\x1B[3J\x1B[H";
var RESET_COLOR = "\x1B[0m";
function bold(string6) {
  return `${RESET_COLOR}\x1B[1m${string6}${RESET_COLOR}`;
}
function dim(string6) {
  return `${RESET_COLOR}\x1B[2m${string6}${RESET_COLOR}`;
}
function removeColor(string6) {
  return string6.replace(/\x1B\[\d+m/g, "");
}
function cursorHorizontalAbsolute(n) {
  return `\x1B[${n}G`;
}
function pad(number4) {
  return number4.toString().padStart(2, "0");
}
function formatTime(date) {
  return join(
    [pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds())],
    ":"
  );
}
var KiB = 1024;
var MiB = 1048576;
function printFileSize(fileSize) {
  const [divided, unit] = fileSize >= MiB ? [fileSize / MiB, "MiB"] : [fileSize / KiB, "KiB"];
  const string6 = toFixed(divided).padStart(4, " ");
  return `${string6} ${unit}`;
}
var SECOND = 1e3;
function printDurationMs(durationMs) {
  const divided = durationMs / SECOND;
  const [string6, unit] = durationMs < SECOND ? [durationMs.toString(), "ms"] : [toFixed(divided), "s"];
  return `${string6} ${unit}`.padStart(6, " ");
}
function toFixed(n) {
  const s1 = n.toFixed(2);
  if (s1.length <= 4) {
    return s1;
  }
  const s2 = n.toFixed(1);
  if (s2.length <= 4) {
    return s2;
  }
  return n.toFixed(0);
}
function capitalize(string6) {
  return string6.slice(0, 1).toUpperCase() + string6.slice(1);
}
function silentlyReadIntEnvValue(value, defaultValue) {
  return /^\d+$/.test(value ?? "") ? Number(value) : defaultValue;
}
var toError = (arg) => toError.jestWorkaround !== void 0 ? toError.jestWorkaround(arg) : arg instanceof Error ? arg : new Error(
  `Caught error not instanceof Error: ${unknownErrorToString(arg)}`
);
var toJsonError = (arg) => arg instanceof import_tiny_decoders.DecoderError ? arg : toError.jestWorkaround !== void 0 ? toError.jestWorkaround(arg) : arg instanceof SyntaxError ? arg : new SyntaxError(
  `Caught error not instanceof DecoderError or SyntaxError: ${unknownErrorToString(
    arg
  )}`
);
function unknownErrorToString(error) {
  return typeof error?.stack === "string" ? error.stack : typeof error?.message === "string" ? error.message : (0, import_tiny_decoders.repr)(error);
}

// src/NonEmptyArray.ts
var Decode = require("tiny-decoders");
function NonEmptyArray(decoder) {
  return Decode.chain(Decode.array(decoder), (array3) => {
    if (isNonEmptyArray(array3)) {
      return array3;
    }
    throw new Decode.DecoderError({
      message: "Expected a non-empty array",
      value: array3
    });
  });
}
function isNonEmptyArray(array3) {
  return array3.length >= 1;
}
function mapNonEmptyArray(array3, f) {
  return array3.map(f);
}
function flattenNonEmptyArray(array3) {
  return array3.flat();
}
function nonEmptyArrayUniqueBy(f, items) {
  const result = [items[0]];
  for (const item of items) {
    if (result.every((otherItem) => f(otherItem) !== f(item))) {
      result.push(item);
    }
  }
  return result;
}

// src/PathHelpers.ts
var fs = require("fs");
var path = require("path");
function absolutePathFromString(from, ...pathStrings) {
  return {
    tag: "AbsolutePath",
    absolutePath: path.resolve(from.absolutePath, ...pathStrings)
  };
}
function absoluteDirname({ absolutePath }) {
  return {
    tag: "AbsolutePath",
    absolutePath: path.dirname(absolutePath)
  };
}
function absoluteRealpath({ absolutePath }) {
  return {
    tag: "AbsolutePath",
    absolutePath: fs.realpathSync(absolutePath)
  };
}
function findClosest(name, absoluteDir) {
  const dir = absoluteDir.absolutePath;
  const entry = path.join(dir, name);
  return fs.existsSync(entry) ? { tag: "AbsolutePath", absolutePath: entry } : dir === path.parse(dir).root ? void 0 : findClosest(name, absoluteDirname(absoluteDir));
}
function longestCommonAncestorPath(paths) {
  const pathArrays = mapNonEmptyArray(
    paths,
    ({ absolutePath }) => absolutePath.split(path.sep)
  );
  const length = Math.min(...pathArrays.map((array3) => array3.length));
  const commonSegments = [];
  for (let index = 0; index < length; index++) {
    const segmentsAtIndex = new Set(pathArrays.map((array3) => array3[index]));
    const uniqueSegment = getSetSingleton(segmentsAtIndex);
    if (uniqueSegment === void 0) {
      break;
    }
    commonSegments.push(uniqueSegment);
  }
  return isNonEmptyArray(commonSegments) ? { tag: "AbsolutePath", absolutePath: join(commonSegments, path.sep) } : void 0;
}

// src/ElmJson.ts
var ElmJson = Decode2.fieldsUnion("type", {
  application: Decode2.fieldsAuto({
    tag: () => "Application",
    "source-directories": NonEmptyArray(Decode2.string)
  }),
  package: () => ({
    tag: "Package"
  })
});
function readAndParse(elmJsonPath) {
  let json = void 0;
  try {
    json = JSON.parse(
      fs2.readFileSync(elmJsonPath.theElmJsonPath.absolutePath, "utf-8")
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ElmJsonReadAsJsonError",
      elmJsonPath,
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmJson: ElmJson(json)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmJsonDecodeError",
      elmJsonPath,
      error
    };
  }
}
function getSourceDirectories(elmJsonPath, elmJson2) {
  const base = absoluteDirname(elmJsonPath.theElmJsonPath);
  switch (elmJson2.tag) {
    case "Application":
      return mapNonEmptyArray(elmJson2["source-directories"], (dir) => ({
        tag: "SourceDirectory",
        theSourceDirectory: absolutePathFromString(base, dir)
      }));
    case "Package":
      return [
        {
          tag: "SourceDirectory",
          theSourceDirectory: absolutePathFromString(base, "src")
        }
      ];
  }
}

// src/ElmMakeError.ts
var Decode5 = require("tiny-decoders");

// src/Errors.ts
var crypto = require("crypto");
var fs4 = require("fs");
var path3 = require("path");
var import_tiny_decoders2 = require("tiny-decoders");
var url = require("url");

// src/ElmWatchJson.ts
var fs3 = require("fs");
var path2 = require("path");
var Decode4 = require("tiny-decoders");

// src/IsWindows.ts
var os = require("os");
var IS_WINDOWS = os.platform() === "win32";

// src/Port.ts
var Decode3 = require("tiny-decoders");
var Port = Decode3.chain(Decode3.number, (number4) => {
  const min = 1;
  const max = 65535;
  if (Number.isInteger(number4) && min <= number4 && number4 <= max) {
    return {
      tag: "Port",
      thePort: number4
    };
  }
  throw new Decode3.DecoderError({
    message: `Expected an integer where ${min} <= port <= ${max}`,
    value: number4
  });
});

// src/ElmWatchJson.ts
var INPUT_NAME = /(^|[/\\])\p{Lu}[_\d\p{L}]*\.elm$/u;
function isValidInputName(name) {
  return INPUT_NAME.test(name);
}
function isValidOutputName(name) {
  return !name.startsWith("-") && name.endsWith(".js") && name !== ".js";
}
var TARGET_NAME = /^[^\s-](?:.*\S)?$/;
function isValidTargetName(name) {
  return TARGET_NAME.test(name);
}
var Target = Decode4.fieldsAuto(
  {
    inputs: NonEmptyArray(
      Decode4.chain(Decode4.string, (string6) => {
        if (isValidInputName(string6)) {
          return string6;
        }
        throw new Decode4.DecoderError({
          message: "Inputs must have a valid module name and end with .elm",
          value: string6
        });
      })
    ),
    output: Decode4.chain(Decode4.string, (output) => {
      if (isValidOutputName(output)) {
        return output;
      }
      throw new Decode4.DecoderError({
        message: "Outputs must end with .js",
        value: Decode4.DecoderError.MISSING_VALUE
      });
    })
  },
  { exact: "throw" }
);
function targetRecordHelper(record3) {
  const entries = Object.entries(record3);
  if (!isNonEmptyArray(entries)) {
    throw new Decode4.DecoderError({
      message: "Expected a non-empty object",
      value: record3
    });
  }
  return Object.fromEntries(
    entries.map(([key, value]) => {
      if (isValidTargetName(key)) {
        return [key, value];
      }
      throw new Decode4.DecoderError({
        message: "Target names must start with a non-whitespace character except `-`,\ncannot contain newlines and must end with a non-whitespace character",
        value: Decode4.DecoderError.MISSING_VALUE,
        key
      });
    })
  );
}
var Config = Decode4.fieldsAuto(
  {
    targets: Decode4.chain(Decode4.record(Target), targetRecordHelper),
    postprocess: Decode4.optional(NonEmptyArray(Decode4.string)),
    port: Decode4.optional(Port)
  },
  { exact: "throw" }
);
function findReadAndParse(cwd) {
  const elmWatchJsonPathRaw = findClosest("elm-watch.json", cwd.path);
  if (elmWatchJsonPathRaw === void 0) {
    return {
      tag: "ElmWatchJsonNotFound"
    };
  }
  const elmWatchJsonPath = {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPathRaw
  };
  let json = void 0;
  try {
    json = JSON.parse(
      fs3.readFileSync(elmWatchJsonPathRaw.absolutePath, "utf-8")
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ReadAsJsonError",
      elmWatchJsonPath,
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmWatchJsonPath,
      config: Config(json)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "DecodeError",
      elmWatchJsonPath,
      error
    };
  }
}
function example(cwd, elmWatchJsonPath, elmMakeParsed) {
  const { elmFiles, output = "build/main.js" } = elmMakeParsed;
  const json = {
    targets: {
      "My target name": {
        inputs: isNonEmptyArray(elmFiles) ? mapNonEmptyArray(
          elmFiles,
          (file) => toUnixPath(
            path2.relative(
              path2.dirname(
                elmWatchJsonPath.theElmWatchJsonPath.absolutePath
              ),
              path2.resolve(cwd.path.absolutePath, file)
            )
          )
        ) : ["src/Main.elm"],
        output
      }
    }
  };
  return JSON.stringify(json, null, 4);
}
function toUnixPath(filePath) {
  return IS_WINDOWS ? filePath.split(path2.sep).join(path2.posix.sep) : filePath;
}
function parseArgsLikeElmMake(args) {
  return args.reduce(
    (passedParsed, { theArg: arg }) => {
      const parsed = { ...passedParsed, justSawOutputFlag: false };
      switch (arg) {
        case "--debug":
        case "--optimize":
          return parsed;
        case "--output":
          return { ...parsed, justSawOutputFlag: true };
        default: {
          if (passedParsed.justSawOutputFlag) {
            return isValidOutputName(arg) ? { ...parsed, output: arg } : parsed;
          }
          const outputPrefix = "--output=";
          if (arg.startsWith(outputPrefix)) {
            const file = arg.slice(outputPrefix.length);
            return isValidOutputName(file) ? { ...parsed, output: file } : parsed;
          }
          return isValidInputName(arg) ? { ...parsed, elmFiles: parsed.elmFiles.concat(arg) } : parsed;
        }
      }
    },
    {
      elmFiles: [],
      output: void 0,
      justSawOutputFlag: false
    }
  );
}

// src/Logger.ts
var readline = require("readline");
var util = require("util");

// src/Env.ts
var NO_COLOR = "NO_COLOR";
var __ELM_WATCH_DEBUG = "__ELM_WATCH_DEBUG";
var __ELM_WATCH_NOT_TTY = "__ELM_WATCH_NOT_TTY";
var WT_SESSION = "WT_SESSION";
var __ELM_WATCH_MOCKED_TIMINGS = "__ELM_WATCH_MOCKED_TIMINGS";
var __ELM_WATCH_EXIT_ON_ERROR = "__ELM_WATCH_EXIT_ON_ERROR";
var __ELM_WATCH_LOADING_MESSAGE_DELAY = "__ELM_WATCH_LOADING_MESSAGE_DELAY";
var __ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS = "__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS";
var __ELM_WATCH_EXIT_ON_WORKER_LIMIT = "__ELM_WATCH_EXIT_ON_WORKER_LIMIT";
var __ELM_WATCH_MAX_PARALLEL = "__ELM_WATCH_MAX_PARALLEL";
var __ELM_WATCH_TMP_DIR = "__ELM_WATCH_TMP_DIR";
var __ELM_WATCH_ELM_TIMEOUT = "__ELM_WATCH_ELM_TIMEOUT";

// src/Logger.ts
var DEFAULT_COLUMNS = 80;
function makeLogger({
  env,
  stdout,
  stderr,
  logDebug
}) {
  const noColor = NO_COLOR in env;
  const handleColor = (string6) => noColor ? removeColor(string6) : string6;
  const config = {
    debug: __ELM_WATCH_DEBUG in env,
    fancy: (!IS_WINDOWS || WT_SESSION in env) && !noColor,
    isTTY: __ELM_WATCH_NOT_TTY in env ? false : stdout.isTTY,
    mockedTimings: __ELM_WATCH_MOCKED_TIMINGS in env,
    get columns() {
      return stdout.columns ?? DEFAULT_COLUMNS;
    }
  };
  return {
    write(message) {
      stdout.write(`${handleColor(message)}
`);
    },
    writeToStderrMakesALotOfSenseHere(message) {
      stderr.write(`${handleColor(message)}
`);
    },
    errorTemplate(template) {
      stdout.write(`${handleColor(template(config.columns))}
`);
    },
    debug(...args) {
      if (config.debug) {
        logDebug(
          join(
            args.map(
              (arg, index) => index === 0 && typeof arg === "string" && !noColor ? bold(arg) : util.inspect(arg, {
                depth: Infinity,
                colors: !noColor,
                maxStringLength: 1e3
              })
            ),
            "\n"
          )
        );
      }
    },
    clearScreen() {
      if (config.isTTY) {
        stdout.write(CLEAR);
      }
    },
    clearScreenDown() {
      if (config.isTTY) {
        readline.clearScreenDown(stdout);
      }
    },
    clearLine(dir) {
      if (config.isTTY) {
        readline.clearLine(stdout, dir);
      }
    },
    moveCursor(dx, dy) {
      if (config.isTTY) {
        readline.moveCursor(stdout, dx, dy);
      }
    },
    config
  };
}

// src/PostprocessShared.ts
var ELM_WATCH_NODE = "elm-watch-node";

// src/Errors.ts
var elmJson = bold("elm.json");
var elmWatchJson = bold("elm-watch.json");
var elmWatchStuffJson = bold("elm-stuff/elm-watch/stuff.json");
var fancyError = (title, location) => (strings, ...values) => (width) => {
  const content = join(
    strings.flatMap((string6, index) => {
      const value = values[index] ?? "";
      return [
        string6,
        typeof value === "function" ? value(width) : value.trim()
      ];
    }),
    ""
  ).trim();
  const prefix = `-- ${title} `;
  const line = "-".repeat(Math.max(0, width - prefix.length));
  const titleWithSeparator = bold(`${prefix}${line}`);
  const maybeLocation = fancyErrorLocation(location);
  return join(
    [
      titleWithSeparator,
      ...maybeLocation === void 0 ? [] : [maybeLocation],
      "",
      content
    ],
    "\n"
  );
};
function toPlainString(errorTemplate) {
  return removeColor(errorTemplate(DEFAULT_COLUMNS));
}
function fancyErrorLocation(location) {
  switch (location.tag) {
    case "ElmJsonPath":
      return location.theElmJsonPath.absolutePath;
    case "ElmWatchJsonPath":
      return location.theElmWatchJsonPath.absolutePath;
    case "ElmWatchStuffJsonPath":
      return location.theElmWatchStuffJsonPath.absolutePath;
    case "OutputPath":
      return dim(`Target: ${location.targetName}`);
    case "ElmWatchNodeScriptPath":
      return url.fileURLToPath(location.theElmWatchNodeScriptFileUrl);
    case "Custom":
      return location.location;
    case "NoLocation":
      return void 0;
  }
}
function readElmWatchJsonAsJson(elmWatchJsonPath, error) {
  return fancyError("TROUBLE READING elm-watch.json", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

${bold("I had trouble reading it as JSON:")}

${error.message}
`;
}
function decodeElmWatchJson(elmWatchJsonPath, error) {
  return fancyError("INVALID elm-watch.json FORMAT", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

${bold("I had trouble with the JSON inside:")}

${printJsonError(error)}
`;
}
function elmWatchJsonNotFound(cwd, args) {
  const example2 = example(
    cwd,
    {
      tag: "ElmWatchJsonPath",
      theElmWatchJsonPath: absolutePathFromString(cwd.path, "elm-watch.json")
    },
    parseArgsLikeElmMake(args)
  );
  return fancyError("elm-watch.json NOT FOUND", { tag: "NoLocation" })`
I read inputs, outputs and options from ${elmWatchJson}.

${bold("But I couldn't find one!")}

You need to create one with JSON like this:

${example2}
`;
}
function debugOptimizeForHot() {
  const make2 = bold("elm-watch make");
  const hot = bold("elm-watch hot");
  return fancyError("REDUNDANT FLAGS", { tag: "NoLocation" })`
${bold("--debug")} and ${bold("--optimize")} only make sense for ${make2}.
When using ${hot}, you can switch mode in the browser.
`;
}
function debugOptimizeClash() {
  return fancyError("CLASHING FLAGS", { tag: "NoLocation" })`
${bold("--debug")} and ${bold("--optimize")} cannot be used at the same time.
`;
}
function unknownFlags(cwd, elmWatchJsonPath, runMode, args, theUnknownFlags) {
  const elmMakeParsed = parseArgsLikeElmMake(args);
  const extra = elmMakeParsed.output !== void 0 ? `
It looks like your arguments might fit in an ${bold("elm make")} command.
If so, you could try moving them to the ${elmWatchJson} I found here:

${elmWatchJsonPath.theElmWatchJsonPath.absolutePath}

For example, you could add some JSON like this:

${example(cwd, elmWatchJsonPath, elmMakeParsed)}
  ` : "";
  return fancyError("UNEXPECTED FLAGS", { tag: "NoLocation" })`
${printRunModeArgsHelp(runMode)}

But you provided these flag-looking args:

${join(
    theUnknownFlags.map((arg) => arg.theArg),
    "\n"
  )}

Try removing those extra flags!

${extra}
`;
}
function printRunModeArgsHelp(runMode) {
  switch (runMode) {
    case "make":
      return `The ${bold(runMode)} command only accepts the flags ${bold(
        "--debug"
      )} and ${bold("--optimize")}.`;
    case "hot":
      return `The ${bold(runMode)} command only accepts no flags at all.`;
  }
}
function unknownTargetsSubstrings(elmWatchJsonPath, knownTargets, theUnknownTargetsSubstrings) {
  return fancyError("UNKNOWN TARGETS SUBSTRINGS", elmWatchJsonPath)`
I read inputs, outputs and options from ${elmWatchJson}.

It contains these targets:

${join(knownTargets, "\n")}

${bold("But none of those match these substrings you gave me:")}

${join(theUnknownTargetsSubstrings, "\n")}

Is something misspelled?
Or do you need to add some more targets?
`;
}
function noCommonRoot(paths) {
  return fancyError("NO COMMON ROOT", { tag: "NoLocation" })`
I could not find a common ancestor for these paths:

${join(
    mapNonEmptyArray(paths, (thePath) => thePath.absolutePath),
    "\n"
  )}

${bold("Compiling files on different drives is not supported.")}
`;
}
function elmJsonNotFound(outputPath, inputs, foundElmJsonPaths) {
  const extra = isNonEmptyArray(foundElmJsonPaths) ? `
Note that I did find an ${elmJson} for some inputs:

${join(
    mapNonEmptyArray(
      foundElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath.theElmJsonPath.absolutePath}`
    ),
    "\n\n"
  )}

Make sure that one single ${elmJson} covers all the inputs together!
      ` : "";
  return fancyError("elm.json NOT FOUND", outputPath)`
I could not find an ${elmJson} for these inputs:

${join(
    mapNonEmptyArray(inputs, (inputPath) => inputPath.originalString),
    "\n"
  )}

Has it gone missing? Maybe run ${bold("elm init")} to create one?

${extra}
`;
}
function nonUniqueElmJsonPaths(outputPath, theNonUniqueElmJsonPaths) {
  return fancyError("NO UNIQUE elm.json", outputPath)`
I went looking for an ${elmJson} for your inputs, but I found more than one!

${join(
    mapNonEmptyArray(
      theNonUniqueElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath.theElmJsonPath.absolutePath}`
    ),
    "\n\n"
  )}

It doesn't make sense to compile Elm files from different projects into one output.

Either split this target, or move the inputs to the same project with the same
${elmJson}.
`;
}
function inputsNotFound(outputPath, inputs) {
  return fancyError("INPUTS NOT FOUND", outputPath)`
You asked me to compile these inputs:

${join(
    mapNonEmptyArray(
      inputs,
      (inputPath) => `${inputPath.originalString} ${dim(
        `(${inputPath.theUncheckedInputPath.absolutePath})`
      )}`
    ),
    "\n"
  )}

${bold("But they don't exist!")}

Is something misspelled? Or do you need to create them?
`;
}
function inputsFailedToResolve(outputPath, inputs) {
  return fancyError("INPUTS FAILED TO RESOLVE", outputPath)`
I start by checking if the inputs you give me exist,
but doing so resulted in errors!

${join(
    mapNonEmptyArray(
      inputs,
      ({ inputPath, error }) => `${inputPath.originalString}:
${error.message}`
    ),
    "\n\n"
  )}

${bold("That's all I know, unfortunately!")}
`;
}
function duplicateInputs(outputPath, duplicates) {
  const isSymlink = (inputPath) => inputPath.theInputPath.absolutePath !== inputPath.realpath.absolutePath;
  const hasSymlink = duplicates.some(({ inputs }) => inputs.some(isSymlink));
  const symlinkText = hasSymlink ? "Note that at least one of the inputs seems to be a symlink. They can be tricky!" : "";
  return fancyError("DUPLICATE INPUTS", outputPath)`
Some of your inputs seem to be duplicates!

${join(
    mapNonEmptyArray(
      duplicates,
      ({ inputs, resolved }) => join(
        [
          ...mapNonEmptyArray(
            inputs,
            (inputPath) => isSymlink(inputPath) ? `${inputPath.originalString} ${dim("(symlink)")}` : inputPath.originalString
          ),
          `-> ${resolved.absolutePath}`
        ],
        "\n"
      )
    ),
    "\n\n"
  )}

Make sure every input is listed just once!

${symlinkText}
`;
}
function duplicateOutputs(elmWatchJsonPath, duplicates) {
  return fancyError("DUPLICATE OUTPUTS", elmWatchJsonPath)`
Some of your outputs seem to be duplicates!

${join(
    mapNonEmptyArray(
      duplicates,
      ({ originalOutputPathStrings, absolutePath }) => join(
        [...originalOutputPathStrings, `-> ${absolutePath.absolutePath}`],
        "\n"
      )
    ),
    "\n\n"
  )}

Make sure every output is listed just once!
`;
}
function elmNotFoundError(location, command) {
  return fancyError("ELM NOT FOUND", location)`
I tried to execute ${bold(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is Elm installed?

Note: If you have installed Elm locally (for example using npm or elm-tooling),
execute elm-watch using npx to make elm-watch automatically pick up that local
installation: ${bold("npx elm-watch")}
`;
}
function commandNotFoundError(outputPath, command) {
  return fancyError("COMMAND NOT FOUND", outputPath)`
I tried to execute ${bold(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is ${bold(command.command)} installed?
`;
}
function otherSpawnError(location, error, command) {
  return fancyError("TROUBLE SPAWNING COMMAND", location)`
I tried to execute ${bold(command.command)}, but I ran into an error!

${error.message}

This happened when trying to run the following commands:

${printCommand(command)}
`;
}
function unexpectedElmMakeOutput(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", outputPath)`
I ran the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with JSON on stderr (compile errors).

${bold("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function unexpectedElmInstallOutput(elmJsonPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", elmJsonPath)`
I tried to make sure all packages are installed by running the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with an error I can recognize (using regex) on stderr.

${bold("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function postprocessStdinWriteError(location, error, command) {
  return fancyError("POSTPROCESS STDIN TROUBLE", location)`
I tried to run your postprocess command:

${printCommand(command)}

Trying to write to its ${bold("stdin")}, I got an error!
${bold("Did you forget to read stdin, maybe?")}

Note: If you don't need stdin in some case, you can pipe it to stdout!

This is the error message I got:

${error.message}
`;
}
function postprocessNonZeroExit(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("POSTPROCESS ERROR", outputPath)`
I ran your postprocess command:

${printCommand(command)}

${bold("It exited with an error:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function elmWatchNodeMissingScript(elmWatchJsonPath) {
  return fancyError("MISSING POSTPROCESS SCRIPT", elmWatchJsonPath)`
You have specified this in ${elmWatchJson}:

"postprocess": [${JSON.stringify(ELM_WATCH_NODE)}]

You need to specify a JavaScript file to run as well, like so:

"postprocess": [${JSON.stringify(ELM_WATCH_NODE)}, "postprocess.js"]
`;
}
function elmWatchNodeImportError(scriptPath, error, stdout, stderr) {
  return fancyError("POSTPROCESS IMPORT ERROR", scriptPath)`
I tried to import your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeDefaultExportNotFunction(scriptPath, imported, typeofDefault, stdout, stderr) {
  const moduleExports = "module.exports";
  return fancyError("MISSING POSTPROCESS DEFAULT EXPORT", scriptPath)`
I imported your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

I expected ${bold("imported.default")} to be a function, but it isn't!

typeof imported.default === ${JSON.stringify(typeofDefault)}

${bold("imported")} is:

${printUnknownValueAsString(imported)}

Here is a sample function to get you started:

// CJS
${moduleExports} = async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

// MJS
export default async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeRunError(scriptPath, args, error, stdout, stderr) {
  return fancyError("POSTPROCESS RUN ERROR", scriptPath)`
I tried to run your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeBadReturnValue(scriptPath, args, returnValue, stdout, stderr) {
  return fancyError("INVALID POSTPROCESS RESULT", scriptPath)`
I ran your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

I expected ${bold("result")} to be a string, but it is:

${printUnknownValueAsString(returnValue)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmMakeJsonParseError(outputPath, error, errorFilePath, command) {
  return fancyError("TROUBLE WITH JSON REPORT", outputPath)`
I ran the following commands:

${printCommand(command)}

I seem to have gotten some JSON back as expected,
but I ran into an error when decoding it:

${printJsonError(error)}

${printErrorFilePath(errorFilePath)}
`;
}
function stuckInProgressState(outputPath, state) {
  return fancyError("STUCK IN PROGRESS", outputPath)`
I thought that all outputs had finished compiling, but my inner state says
this target is still in the ${bold(state)} phase.

${bold("This is not supposed to ever happen.")}
`;
}
function creatingDummyFailed(elmJsonPath, error) {
  return fancyError("FILE SYSTEM TROUBLE", elmJsonPath)`
I tried to make sure that all packages are installed. To do that, I need to
create a temporary dummy .elm file but that failed:

${error.message}
`;
}
function elmInstallError(elmJsonPath, title, message) {
  return fancyError(title, elmJsonPath)`
${message}
`;
}
function readElmJsonAsJson(elmJsonPath, error) {
  return fancyError("TROUBLE READING elm.json", elmJsonPath)`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold("I had trouble reading it as JSON:")}

${error.message}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function decodeElmJson(elmJsonPath, error) {
  return fancyError("INVALID elm.json FORMAT", elmJsonPath)`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold("I had trouble with the JSON inside:")}

${printJsonError(error)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function readElmWatchStuffJsonAsJson(elmWatchStuffJsonPath, error) {
  return fancyError(
    "TROUBLE READING elm-stuff/elm-watch/stuff.json",
    elmWatchStuffJsonPath
  )`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold("I had trouble reading it as JSON:")}

${error.message}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function decodeElmWatchStuffJson(elmWatchStuffJsonPath, error) {
  return fancyError(
    "INVALID elm-stuff/elm-watch/stuff.json FORMAT",
    elmWatchStuffJsonPath
  )`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold("I had trouble with the JSON inside:")}

${printJsonError(error)}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function elmWatchStuffJsonWriteError(elmWatchStuffJsonPath, error) {
  return fancyError(
    "TROUBLE WRITING elm-stuff/elm-watch/stuff.json",
    elmWatchStuffJsonPath
  )`
I write stuff to ${elmWatchStuffJson} to remember some things between runs.

${bold("I had trouble writing that file:")}

${error.message}

The file contains nothing essential, but something weird is going on.
`;
}
function importWalkerFileSystemError(outputPath, error) {
  return fancyError("TROUBLE READING ELM FILES", outputPath)`
When figuring out all Elm files that your inputs depend on I read a lot of Elm files.
Doing so I encountered this error:

${error.message}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function readOutputError(outputPath, error, triedPath) {
  return fancyError("TROUBLE READING OUTPUT", outputPath)`
I managed to compile your code. Then I tried to read the output:

${triedPath.absolutePath}

Doing so I encountered this error:

${error.message}
`;
}
function writeOutputError(outputPath, error, reasonForWriting) {
  return fancyError("TROUBLE WRITING OUTPUT", outputPath)`
I managed to compile your code and read the generated file:

${outputPath.temporaryOutputPath.absolutePath}

${printWriteOutputErrorReasonForWriting(reasonForWriting)}

${outputPath.theOutputPath.absolutePath}

But I encountered this error:

${error.message}
`;
}
function printWriteOutputErrorReasonForWriting(reasonForWriting) {
  switch (reasonForWriting) {
    case "InjectWebSocketClient":
      return "I injected code for hot reloading, and then tried to write that to the output path:";
    case "Postprocess":
      return "After running your postprocess command, I tried to write the result of that to the output path:";
  }
}
function writeProxyOutputError(outputPath, error) {
  return fancyError("TROUBLE WRITING DUMMY OUTPUT", outputPath)`
There are no websocket connections for this target, so I only typecheck the
code. That went well. Then I tried to write a dummy output file here:

${outputPath.theOutputPath.absolutePath}

Doing so I encountered this error:

${error.message}
`;
}
function portConflictForNoPort(error) {
  return fancyError("PORT CONFLICT", { tag: "NoLocation" })`
I ask the operating system for an arbitrary available port for the
web socket server.

The operating system is supposed to always be able to find an available port,
but it looks like that wasn't the case this time!

This is the error message I got:

${error.message}
  `;
}
function portConflictForPersistedPort(elmWatchStuffJsonPath, port) {
  return fancyError("PORT CONFLICT", elmWatchStuffJsonPath)`
I ask the operating system for an arbitrary available port for the
web socket server.

I then save the port I got to ${elmWatchStuffJson}. Otherwise I would
get a new port number on each restart, which means that if you had tabs
open in the browser they would try to connect to the old port number.

I tried to use such a saved port number from a previous run (or from previous
configuration). But now that port (${port.thePort.toString()}) wasn't available!

Most likely you already have elm-watch running somewhere else! If so,
find it and use that, or kill it.

If not, something else could have started using port ${port.thePort.toString()}
(though it's not very likely.) Then you can either try to find what that is,
or remove ${elmWatchStuffJson} here:

${elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath}

Then I will ask the operating system for a new arbitrary available port.
  `;
}
function portConflictForPortFromConfig(elmWatchJsonPath, port) {
  return fancyError("PORT CONFLICT", elmWatchJsonPath)`
In your ${elmWatchJson} you have this:

"port": ${JSON.stringify(port.thePort)}

But something else seems to already be running on that port!
You might already have elm-watch running somewhere, or it could be a completely
different program.

You need to either find and stop that other thing, switch to another port or
remove "port" from ${elmWatchJson} (which will use an arbitrary available port.)
  `;
}
function watcherError(error) {
  return fancyError("WATCHER ERROR", { tag: "NoLocation" })`
The file watcher encountered an error, which means that it cannot continue.
elm-watch is powered by its file watcher, so I have to exit at this point.

See if this is something you can solve by maybe removing some problematic files
or something!

This is the error message I got:

${error.message}
  `;
}
function webSocketBadUrl(expectedStart, actualUrlString) {
  return `
I expected the web socket connection URL to start with:

${expectedStart}

But it looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here.
  `.trim();
}
function webSocketParamsDecodeError(error, actualUrlString) {
  return `
I ran into trouble parsing the web socket connection URL parameters:

${printJsonError(error)}

The URL looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here. Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `.trim();
}
function webSocketWrongVersion(expectedVersion, actualVersion) {
  return `
The compiled JavaScript code running in the browser says it was compiled with:

elm-watch ${actualVersion}

But the server is:

elm-watch ${expectedVersion}

Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `.trim();
}
function webSocketTargetNotFound(targetName, enabledOutputs, disabledOutputs) {
  const extra = isNonEmptyArray(disabledOutputs) ? `

These targets are also available in elm-watch.json, but are not enabled (because of the CLI arguments passed):

${join(
    mapNonEmptyArray(disabledOutputs, (outputPath) => outputPath.targetName),
    "\n"
  )}
  `.trimEnd() : "";
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

But I can't find that target in elm-watch.json!

These targets are available in elm-watch.json:

${join(
    enabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}${extra}

Maybe this target used to exist in elm-watch.json, but you removed or changed it?
  `.trim();
}
function webSocketTargetDisabled(targetName, enabledOutputs, disabledOutputs) {
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

That target does exist in elm-watch.json, but isn't enabled.

These targets are enabled via CLI arguments:

${join(
    enabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}

These targets exist in elm-watch.json but aren't enabled:

${join(
    disabledOutputs.map((outputPath) => outputPath.targetName),
    "\n"
  )}

If you want to have this target compiled, restart elm-watch either with more CLI arguments or no CLI arguments at all!
  `.trim();
}
function webSocketDecodeError(error) {
  return `
The compiled JavaScript code running in the browser seems to have sent a message that the web socket server cannot recognize!

${printJsonError(error)}

The web socket code I generate is supposed to always send correct messages, so something is up here.
  `.trim();
}
function printPATH(env, isWindows) {
  if (isWindows) {
    return printPATHWindows(env);
  }
  const { PATH } = env;
  if (PATH === void 0) {
    return "I can't find any program, because process.env.PATH is undefined!";
  }
  const pathList = PATH.split(path3.delimiter);
  return `
This is what the PATH environment variable looks like:

${join(pathList, "\n")}
  `.trim();
}
function printPATHWindows(env) {
  const pathEntries = Object.entries(env).flatMap(
    ([key, value]) => key.toUpperCase() === "PATH" && value !== void 0 ? [[key, value]] : []
  );
  if (!isNonEmptyArray(pathEntries)) {
    return "I can't find any program, because I can't find any PATH-like environment variables!";
  }
  if (pathEntries.length === 1) {
    const [key, value] = pathEntries[0];
    return `
This is what the ${key} environment variable looks like:

${join(value.split(path3.delimiter), "\n")}
    `.trim();
  }
  const pathEntriesString = join(
    pathEntries.map(
      ([key, value]) => join([`${key}:`, ...value.split(path3.delimiter)], "\n")
    ),
    "\n\n"
  );
  return `
You seem to have several PATH-like environment variables set. The last one
should be the one that is actually used, but it's better to have a single one!

${pathEntriesString}
  `.trim();
}
function printCommand(command) {
  const stdin = command.stdin === void 0 ? "" : `${commandToPresentationName([
    "printf",
    truncate(command.stdin.toString("utf8"))
  ])} | `;
  return `
${commandToPresentationName(["cd", command.options.cwd.absolutePath])}
${stdin}${commandToPresentationName([command.command, ...command.args])}
`;
}
function commandToPresentationName(command) {
  return join(
    command.map(
      (part) => part === "" ? "''" : join(
        part.split(/(')/).map(
          (subPart) => subPart === "" ? "" : subPart === "'" ? "\\'" : /^[\w.,:/=@%+-]+$/.test(subPart) ? subPart : `'${subPart}'`
        ),
        ""
      )
    ),
    " "
  );
}
function printExitReason(exitReason2) {
  switch (exitReason2.tag) {
    case "ExitCode":
      return `exit ${exitReason2.exitCode}`;
    case "Signal":
      return `signal ${exitReason2.signal}`;
    case "Unknown":
      return "unknown exit reason";
  }
}
var printStdio = (stdout, stderr) => (width) => stdout !== "" && stderr === "" ? limitStdio(stdout, width) : stdout === "" && stderr !== "" ? limitStdio(stderr, width) : stdout === "" && stderr === "" ? dim("(no output)") : `
STDOUT:
${limitStdio(stdout, width)}

STDERR:
${limitStdio(stderr, width)}
`.trim();
var printElmWatchNodeStdio = (stdout, stderr) => (width) => stdout === "" && stderr === "" ? "" : `
STDOUT:
${limitStdio(stdout, width)}

STDERR:
${limitStdio(stderr, width)}
`.trim();
function limitStdio(string6, width) {
  const max = 100;
  const lines = string6.trimEnd().split("\n");
  const result = [];
  let usedLines = 0;
  for (const line of lines) {
    const count = Math.ceil(line.length / width);
    const available = max - usedLines;
    if (available <= 0) {
      break;
    } else if (count > available) {
      const take = available * width;
      const left2 = line.length - take;
      result.push(
        `${line.slice(0, take)} ${dim(
          left2 === 1 ? "1 more character" : `${left2} more characters`
        )}`
      );
      usedLines += available;
      break;
    } else {
      result.push(line);
      usedLines += count;
    }
  }
  const joined = join(result, "\n");
  const left = lines.length - result.length;
  return left > 0 ? `${joined}
${dim(left === 1 ? "1 more line" : `${left} more lines`)}` : joined;
}
function printErrorFilePath(errorFilePath) {
  switch (errorFilePath.tag) {
    case "AbsolutePath":
      return `
I wrote that to this file so you can inspect it:

${errorFilePath.absolutePath}
      `.trim();
    case "WritingErrorFileFailed":
      return `
I tried to write that to this file:

${errorFilePath.attemptedPath.absolutePath}

${bold("But that failed too:")}

${errorFilePath.error.message}
      `.trim();
    case "ErrorFileBadContent":
      return `
I wrote this error to a file so you can inspect and possibly report it more easily.

This is the data that caused the error:

${errorFilePath.content}
      `.trim();
  }
}
function printUnknownValueAsString(value) {
  switch (value.tag) {
    case "UnknownValueAsString":
      return value.value;
  }
}
function printElmWatchNodeImportCommand(scriptPath) {
  return `const imported = await import(${JSON.stringify(
    scriptPath.theElmWatchNodeScriptFileUrl
  )})`;
}
function printElmWatchNodeRunCommand(args) {
  const truncated = {
    ...args,
    code: truncate(args.code)
  };
  return `const result = await imported.default(${JSON.stringify(
    truncated,
    null,
    2
  )})`;
}
function truncate(string6) {
  const roughLimit = 20;
  const half = Math.floor(roughLimit / 2);
  return string6.length <= roughLimit ? string6 : `${string6.slice(0, half)}...${string6.slice(-half)}`;
}
function printJsonError(error) {
  return error instanceof import_tiny_decoders2.DecoderError ? error.format() : error.message;
}
function tryWriteErrorFile({
  cwd,
  name,
  content,
  hash: hash3
}) {
  const jsonPath = absolutePathFromString(
    cwd,
    `elm-watch-${name}-${sha256(hash3)}.txt`
  );
  try {
    fs4.writeFileSync(jsonPath.absolutePath, content);
    return jsonPath;
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "WritingErrorFileFailed",
      error,
      attemptedPath: jsonPath
    };
  }
}
function sha256(string6) {
  return crypto.createHash("sha256").update(string6).digest("hex");
}

// src/ElmMakeError.ts
var Color = Decode5.stringUnion({
  red: null,
  RED: null,
  magenta: null,
  MAGENTA: null,
  yellow: null,
  YELLOW: null,
  green: null,
  GREEN: null,
  cyan: null,
  CYAN: null,
  blue: null,
  BLUE: null,
  black: null,
  BLACK: null,
  white: null,
  WHITE: null
});
var MessageChunk = Decode5.multi({
  string: (string6) => ({
    tag: "UnstyledText",
    string: string6
  }),
  object: Decode5.chain(
    Decode5.fieldsAuto({
      bold: Decode5.boolean,
      underline: Decode5.boolean,
      color: Decode5.nullable(Color, void 0),
      string: Decode5.string
    }),
    (style) => ({
      tag: "StyledText",
      style
    })
  )
});
var Position = Decode5.fieldsAuto({
  line: Decode5.number,
  column: Decode5.number
});
var Region = Decode5.fieldsAuto({
  start: Position,
  end: Position
});
var Problem = Decode5.fieldsAuto({
  title: Decode5.string,
  region: Region,
  message: Decode5.array(MessageChunk)
});
var CompileError = Decode5.fieldsAuto({
  path: Decode5.chain(
    Decode5.string,
    (string6) => ({
      tag: "AbsolutePath",
      absolutePath: string6
    })
  ),
  name: Decode5.string,
  problems: NonEmptyArray(Problem)
});
var GeneralError = Decode5.fieldsAuto({
  tag: () => "GeneralError",
  path: Decode5.nullable(
    Decode5.chain(
      Decode5.stringUnion({
        "elm.json": null
      }),
      (tag) => ({ tag })
    ),
    { tag: "NoPath" }
  ),
  title: Decode5.string,
  message: Decode5.array(MessageChunk)
});
var ElmMakeError = Decode5.fieldsUnion("type", {
  error: GeneralError,
  "compile-errors": Decode5.fieldsAuto({
    tag: () => "CompileErrors",
    errors: NonEmptyArray(CompileError)
  })
});
function renderGeneralError(outputPath, elmJsonPath, error, extraError) {
  return fancyError(
    error.title,
    generalErrorPath(outputPath, elmJsonPath, error.path)
  )`
${extraError ?? ""}

${join(error.message.map(renderMessageChunk), "")}
  `;
}
function generalErrorPath(outputPath, elmJsonPath, path7) {
  switch (path7.tag) {
    case "NoPath":
      return outputPath;
    case "elm.json":
      return elmJsonPath;
  }
}
function renderProblem(filePath, problem, extraError) {
  const location = join(
    [
      filePath.absolutePath,
      problem.region.start.line.toString(),
      problem.region.start.column.toString()
    ],
    ":"
  );
  return fancyError(problem.title, { tag: "Custom", location })`
${extraError ?? ""}

${join(problem.message.map(renderMessageChunk), "")}
`;
}
function renderMessageChunk(chunk) {
  switch (chunk.tag) {
    case "UnstyledText":
      return chunk.string;
    case "StyledText": {
      const { style } = chunk;
      return (style.bold ? "\x1B[1m" : "") + (style.underline ? "\x1B[4m" : "") + (style.color === void 0 ? "" : renderColor(style.color)) + style.string + RESET_COLOR;
    }
  }
}
function renderColor(color) {
  switch (color) {
    case "red":
      return "\x1B[31m";
    case "RED":
      return "\x1B[91m";
    case "magenta":
      return "\x1B[35m";
    case "MAGENTA":
      return "\x1B[95m";
    case "yellow":
      return "\x1B[33m";
    case "YELLOW":
      return "\x1B[93m";
    case "green":
      return "\x1B[32m";
    case "GREEN":
      return "\x1B[92m";
    case "cyan":
      return "\x1B[36m";
    case "CYAN":
      return "\x1B[96m";
    case "blue":
      return "\x1B[34m";
    case "BLUE":
      return "\x1B[94m";
    case "black":
      return "\x1B[30m";
    case "BLACK":
      return "\x1B[90m";
    case "white":
      return "\x1B[37m";
    case "WHITE":
      return "\x1B[97m";
  }
}

// src/HashSet.ts
var util2 = require("util");
var _a;
var HashSet = class {
  constructor(values) {
    this._set = /* @__PURE__ */ new Set();
    this[_a] = "HashSet";
    if (values !== void 0 && values !== null) {
      for (const value of values) {
        this._set.add(hash(value));
      }
    }
  }
  get size() {
    return this._set.size;
  }
  has(value) {
    return this._set.has(hash(value));
  }
  add(value) {
    this._set.add(hash(value));
    return this;
  }
  delete(value) {
    return this._set.delete(hash(value));
  }
  clear() {
    this._set.clear();
  }
  forEach(callback) {
    return callback;
  }
  *keys() {
    for (const value of this._set.keys()) {
      yield JSON.parse(value);
    }
  }
  values() {
    return this.keys();
  }
  *entries() {
    for (const value of this.keys()) {
      yield [value, value];
    }
  }
  [Symbol.iterator]() {
    return this.keys();
  }
  [(_a = Symbol.toStringTag, util2.inspect.custom)]() {
    return new Set(this);
  }
};
function hash(value) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a < b ? -1 : 1)
    )
  );
}

// src/ImportWalker.ts
var fs5 = require("fs");
var path4 = require("path");
var util3 = require("util");

// src/Parser.ts
var MODULE_NAME = /^\p{Lu}[_\d\p{L}]*(?:\.\p{Lu}[_\d\p{L}]*)*$/u;
var CR = 13;
var HYPHEN = 45;
var LEFT_BRACE = 123;
var LF = 10;
var RIGHT_BRACE = 125;
var SPACE = 32;
function isImport(chars) {
  return chars.length === 6 && chars[0] === 105 && chars[1] === 109 && chars[2] === 112 && chars[3] === 111 && chars[4] === 114 && chars[5] === 116;
}
var initialReadState = () => ({
  tokenizerState: { tag: "Initial", chars: [], multilineCommentLevel: 0 },
  parserState: { tag: "StartOfFile" },
  importedModules: []
});
function readChar(char, readState) {
  const maybeToken = tokenize(char, readState.tokenizerState);
  if (maybeToken === void 0) {
    return;
  }
  const maybeModuleName = parse2(maybeToken, readState.parserState);
  if (maybeModuleName !== void 0) {
    readState.importedModules.push(maybeModuleName);
  }
}
function isNonImport(readState) {
  return readState.parserState.tag === "NonImport";
}
function finalize(readState) {
  if (readState.tokenizerState.tag !== "Initial") {
    return readState.importedModules;
  }
  const maybeLastToken = flush(readState.tokenizerState.chars);
  if (maybeLastToken === void 0) {
    return readState.importedModules;
  }
  const maybeLastModuleName = parse2(maybeLastToken, readState.parserState);
  if (maybeLastModuleName === void 0) {
    return readState.importedModules;
  }
  readState.importedModules.push(maybeLastModuleName);
  return readState.importedModules;
}
function tokenize(char, tokenizerState) {
  switch (tokenizerState.tag) {
    case "Initial":
      switch (char) {
        case SPACE: {
          const maybeToken = flush(tokenizerState.chars);
          tokenizerState.chars = [];
          return maybeToken;
        }
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return flush(tokenizerState.chars);
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return flush(tokenizerState.chars);
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return flush(tokenizerState.chars);
        default:
          tokenizerState.chars.push(char);
          return void 0;
      }
    case "MaybeNewChunk":
      switch (char) {
        case SPACE:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [];
          return void 0;
        case CR:
        case LF:
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [char];
          return { tag: "NewChunk" };
      }
    case "MaybeMultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel = 1;
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [LEFT_BRACE];
          return tokenize(char, tokenizerState);
      }
    case "MultilineComment":
      switch (char) {
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MultilineComment-";
          return void 0;
        default:
          return void 0;
      }
    case "MultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel++;
          return void 0;
        case LEFT_BRACE:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MultilineComment-":
      switch (char) {
        case RIGHT_BRACE:
          if (tokenizerState.multilineCommentLevel <= 1) {
            tokenizerState.tag = "Initial";
            tokenizerState.chars = [];
          } else {
            tokenizerState.tag = "MultilineComment";
            tokenizerState.multilineCommentLevel--;
          }
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MaybeSinglelineComment-":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "SinglelineComment";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [HYPHEN];
          return tokenize(char, tokenizerState);
      }
    case "SinglelineComment":
      switch (char) {
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return void 0;
        default:
          return void 0;
      }
  }
}
function flush(chars) {
  return isNonEmptyArray(chars) ? { tag: "Word", chars } : void 0;
}
function parse2(token, parserState) {
  switch (parserState.tag) {
    case "StartOfFile":
      switch (token.tag) {
        case "NewChunk":
          return void 0;
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
      }
    case "NewChunk":
      switch (token.tag) {
        case "NewChunk":
          return void 0;
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "NonImport";
            return void 0;
          }
      }
    case "Import":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word": {
          const string6 = Buffer.from(token.chars).toString();
          if (MODULE_NAME.test(string6)) {
            parserState.tag = "Ignore";
            return split(string6, ".");
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
        }
      }
    case "Ignore":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word":
          return void 0;
      }
    case "NonImport":
      return void 0;
  }
}

// src/ImportWalker.ts
function walkImports(sourceDirectories, inputPaths) {
  const allRelatedElmFilePaths = new Set(
    inputPaths.flatMap(
      (inputPath) => initialRelatedElmFilePaths(sourceDirectories, inputPath)
    )
  );
  allRelatedElmFilePaths[util3.inspect.custom] = () => Array.from(allRelatedElmFilePaths);
  const visitedModules = /* @__PURE__ */ new Set();
  try {
    for (const inputPath of inputPaths) {
      walkImportsHelper(
        mapNonEmptyArray(sourceDirectories, (sourceDirectory) => ({
          sourceDirectory,
          children: new Set(readdirSync2(sourceDirectory.theSourceDirectory))
        })),
        inputPath.realpath.absolutePath,
        allRelatedElmFilePaths,
        visitedModules
      );
    }
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ImportWalkerFileSystemError",
      error,
      relatedElmFilePathsUntilError: allRelatedElmFilePaths
    };
  }
  return { tag: "Success", allRelatedElmFilePaths };
}
function walkImportsHelper(sourceDirectories, elmFilePath, allRelatedElmFilePaths, visitedModules) {
  if (!fs5.existsSync(elmFilePath)) {
    return;
  }
  const importedModules = parse3(elmFilePath);
  for (const importedModule of importedModules) {
    const relativePath = `${importedModule.join(path4.sep)}.elm`;
    if (!visitedModules.has(relativePath)) {
      visitedModules.add(relativePath);
      for (const { sourceDirectory, children } of sourceDirectories) {
        const newElmFilePath = sourceDirectory.theSourceDirectory.absolutePath + path4.sep + relativePath;
        allRelatedElmFilePaths.add(newElmFilePath);
        const child = importedModule.length === 1 ? `${importedModule[0]}.elm` : importedModule[0];
        if (children.has(child)) {
          walkImportsHelper(
            sourceDirectories,
            newElmFilePath,
            allRelatedElmFilePaths,
            visitedModules
          );
        }
      }
    }
  }
}
function parse3(elmFilePath) {
  const readState = initialReadState();
  const handle = fs5.openSync(elmFilePath, "r");
  const buffer = Buffer.alloc(2048);
  let bytesRead = 0;
  outer:
    while ((bytesRead = fs5.readSync(handle, buffer)) > 0) {
      for (const char of buffer.slice(0, bytesRead)) {
        readChar(char, readState);
        if (isNonImport(readState)) {
          break outer;
        }
      }
    }
  fs5.closeSync(handle);
  return finalize(readState);
}
function initialRelatedElmFilePaths(sourceDirectories, inputPath) {
  const inputPathString = inputPath.realpath.absolutePath;
  return [
    inputPathString,
    ...sourceDirectories.flatMap((sourceDirectory) => {
      const prefix = sourceDirectory.theSourceDirectory.absolutePath + path4.sep;
      return inputPathString.startsWith(prefix) ? sourceDirectories.map(
        (sourceDirectory2) => sourceDirectory2.theSourceDirectory.absolutePath + path4.sep + inputPathString.slice(prefix.length)
      ) : [];
    })
  ];
}
function readdirSync2(dir) {
  try {
    return fs5.readdirSync(dir.absolutePath);
  } catch {
    return [];
  }
}

// src/Inject.ts
var ClientCode = require("./ClientCode");
var REPLACEMENT_REGEX = /^(?:function (F|_Platform_initialize|_Platform_export|_Browser_application|_Scheduler_binding|_Scheduler_step)\(|var (_VirtualDom_init|\$elm\$browser\$Browser\$sandbox|_Platform_worker|_Browser_element|_Browser_document|_Debugger_element|_Debugger_document) =).*\r?\n?\{(?:.*\r?\n)*?\}\)?;?$/gm;
var PLACEHOLDER_REGEX = /%(\w+)%/g;
var REPLACEMENTS = {
  _Platform_initialize: `
// This whole function was changed by elm-watch.
function _Platform_initialize(programType, debugMetadata, flagDecoder, args, init, impl, stepperBuilder)
{
	if (args === "__elmWatchReturnData") {
		return { impl: impl, debugMetadata: debugMetadata, flagDecoder : flagDecoder, programType: programType };
	}

	var flags = _Json_wrap(args ? args['flags'] : undefined);
	var flagResult = A2(_Json_run, flagDecoder, flags);
	$elm$core$Result$isOk(flagResult) || _Debug_crash(2 /**/, _Json_errorToString(flagResult.a) /**/);
	var managers = {};
	var initUrl = programType === "Browser.application" ? _Browser_getUrl() : undefined;
	window.__ELM_WATCH_INIT_URL = initUrl;
	var initPair = init(flagResult.a);
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);
	var update;
	var subscriptions;

	function setUpdateAndSubscriptions() {
		update = impl.%update% || impl._impl.%update%;
		subscriptions = impl.%subscriptions% || impl._impl.%subscriptions%;
		if (typeof $elm$browser$Debugger$Main$wrapUpdate !== "undefined") {
			update = $elm$browser$Debugger$Main$wrapUpdate(update);
			subscriptions = $elm$browser$Debugger$Main$wrapSubs(subscriptions);
		}
	}

	function sendToApp(msg, viewMetadata) {
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	setUpdateAndSubscriptions();
	_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));

	function __elmWatchHotReload(newData, new_Platform_effectManagers, new_Scheduler_enqueue, moduleName) {
		_Platform_enqueueEffects(managers, _Platform_batch(_List_Nil), _Platform_batch(_List_Nil));
		_Scheduler_enqueue = new_Scheduler_enqueue;

		for (var key in new_Platform_effectManagers) {
			var manager = new_Platform_effectManagers[key];
			if (!(key in _Platform_effectManagers)) {
				_Platform_effectManagers[key] = manager;
				managers[key] = _Platform_instantiateManager(manager, sendToApp);
				if (manager.a) {
					console.info("elm-watch: A new port '" + key + "' was added. You might want to reload the page!");
					manager.a(key, sendToApp)
				}
			}
		}

		for (var key in newData.impl) {
			if (key === "_impl" && impl._impl) {
				for (var subKey in newData.impl[key]) {
					impl._impl[subKey] = newData.impl[key][subKey];
				}
			} else {
				impl[key] = newData.impl[key];
			}
		}

		var newFlagResult = A2(_Json_run, newData.flagDecoder, flags);
		if (!$elm$core$Result$isOk(newFlagResult)) {
			return { tag: "ReloadPage", reason: "the flags type in \`" + moduleName + "\` changed and now the passed flags aren't correct anymore. The idea is to try to run with new flags!\\nThis is the error:\\n" + _Json_errorToString(newFlagResult.a) };
		}
		if (!_Utils_eq_elmWatchInternal(debugMetadata, newData.debugMetadata)) {
			return { tag: "ReloadPage", reason: "the message type in \`" + moduleName + '\` changed in debug mode ("debug metadata" changed).' };
		}
		init = impl.%init% || impl._impl.%init%;
		if (typeof $elm$browser$Debugger$Main$wrapInit !== "undefined") {
			init = A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(newData.debugMetadata), initPair.a.popout, init);
		}
		window.__ELM_WATCH_INIT_URL = initUrl;
		var newInitPair = init(newFlagResult.a);
		if (!_Utils_eq_elmWatchInternal(initPair, newInitPair)) {
			return { tag: "ReloadPage", reason: "\`" + moduleName + ".init\` returned something different than last time. Let's start fresh!" };
		}

		setUpdateAndSubscriptions();
		stepper(model, true /* isSync */);
		_Platform_enqueueEffects(managers, _Platform_batch(_List_Nil), subscriptions(model));
		return { tag: "Success" };
	}

	return Object.defineProperties(
		ports ? { ports: ports } : {},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchProgramType: { value: programType },
		}
	);
}

// This whole function was added by elm-watch.
// Copy-paste of _Utils_eq but does not assume that x and y have the same type,
// and considers functions to always be equal.
function _Utils_eq_elmWatchInternal(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp_elmWatchInternal(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp_elmWatchInternal(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

// This whole function was added by elm-watch.
function _Utils_eqHelp_elmWatchInternal(x, y, depth, stack)
{
	if (x === y) {
		return true;
	}

	var xType = _Utils_typeof_elmWatchInternal(x);
	var yType = _Utils_typeof_elmWatchInternal(y);

	if (xType !== yType) {
		return false;
	}

	switch (xType) {
		case "primitive":
			return false;
		case "function":
			return true;
	}

	if (x.$ !== y.$) {
		return false;
	}

	if (x.$ === 'Set_elm_builtin') {
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	} else if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin' || x.$ < 0) {
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}

	if (Object.keys(x).length !== Object.keys(y).length) {
		return false;
	}

	if (depth > 100) {
		stack.push(_Utils_Tuple2(x, y));
		return true;
	}

	for (var key in x) {
		if (!_Utils_eqHelp_elmWatchInternal(x[key], y[key], depth + 1, stack)) {
			return false;
		}
	}
	return true;
}

// This whole function was added by elm-watch.
function _Utils_typeof_elmWatchInternal(x)
{
	var type = typeof x;
	return type === "function"
		? "function"
		: type !== "object" || type === null
		? "primitive"
		: "objectOrArray";
}
				`.trim(),
  F: `
var _Platform_effectManagers = {}, _Scheduler_enqueue; // added by elm-watch

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}
  `.trim(),
  _VirtualDom_init: `
// This whole function was changed by elm-watch.
var _VirtualDom_init = F4(function(virtualNode, flagDecoder, debugMetadata, args)
{
	var programType = "Html";

	if (args === "__elmWatchReturnData") {
		return { virtualNode: virtualNode, programType: programType };
	}

	/**_UNUSED/ // always UNUSED with elm-watch
	var node = args['node'];
	//*/
	/**/
	var node = args && args['node'] ? args['node'] : _Debug_crash(0);
	//*/

	var nextNode = _VirtualDom_render(virtualNode, function() {});
	node.parentNode.replaceChild(nextNode, node);
	node = nextNode;
	var sendToApp = function() {};

	function __elmWatchHotReload(newData) {
		var patches = _VirtualDom_diff(virtualNode, newData.virtualNode);
		node = _VirtualDom_applyPatches(node, virtualNode, patches, sendToApp);
		virtualNode = newData.virtualNode;
		return { tag: "Success" };
	}

	return Object.defineProperties(
		{},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchProgramType: { value: programType },
		}
	);
});
				`.trim(),
  _Platform_export: `
// This whole function was changed by elm-watch.
function _Platform_export(exports)
{
	var reloadReasons = _Platform_mergeExportsElmWatch('Elm', scope['Elm'] || (scope['Elm'] = {}), exports);
	if (reloadReasons.length > 0) {
		throw new Error(["ELM_WATCH_RELOAD_NEEDED"].concat(Array.from(new Set(reloadReasons))).join("\\n\\n---\\n\\n"));
	}
}

// This whole function was added by elm-watch.
function _Platform_mergeExportsElmWatch(moduleName, obj, exports)
{
	var reloadReasons = [];
	for (var name in exports) {
		if (name === "init") {
			if ("init" in obj) {
				if ("__elmWatchApps" in obj) {
					var data = exports.init("__elmWatchReturnData");
					for (var index = 0; index < obj.__elmWatchApps.length; index++) {
						var app = obj.__elmWatchApps[index];
						if (app.__elmWatchProgramType !== data.programType) {
							reloadReasons.push("\`" + moduleName + ".main\` changed from \`" + app.__elmWatchProgramType + "\` to \`" + data.programType + "\`.");
						} else {
							var result;
							try {
								result = app.__elmWatchHotReload(data, _Platform_effectManagers, _Scheduler_enqueue, moduleName);
								switch (result.tag) {
									case "Success":
										break;
									case "ReloadPage":
										reloadReasons.push(result.reason);
										break;
								}
							} catch (error) {
								reloadReasons.push("hot reload for \`" + moduleName + "\` failed, probably because of incompatible model changes.\\nThis is the error:\\n" + error + "\\n" + (error ? error.stack : ""));
							}
						}
					}
				} else {
					throw new Error("elm-watch: I'm trying to create \`" + moduleName + ".init\`, but it already exists and wasn't created by elm-watch. Maybe a duplicate script is getting loaded accidentally?");
				}
			} else {
				obj.__elmWatchApps = [];
				obj.init = function() {
					var app = exports.init.apply(exports, arguments);
					obj.__elmWatchApps.push(app);
					window.__ELM_WATCH_ON_INIT();
					return app;
				};
			}
		} else {
			var innerReasons = _Platform_mergeExportsElmWatch(moduleName + "." + name, obj[name] || (obj[name] = {}), exports[name]);
			reloadReasons = reloadReasons.concat(innerReasons);
		}
	}
	return reloadReasons;
}
				`.trim(),
  _Browser_application: `
// This function was slightly modified by elm-watch.
function _Browser_application(impl)
{
	// var onUrlChange = impl.onUrlChange; // commented out by elm-watch
	// var onUrlRequest = impl.onUrlRequest; // commented out by elm-watch
	// var key = function() { key.a(onUrlChange(_Browser_getUrl())); }; // commented out by elm-watch
	var key = function() { key.a(impl.%onUrlChange%(_Browser_getUrl())); }; // added by elm-watch

	return _Browser_document({
		%setup%: function(sendToApp)
		{
			key.a = sendToApp;
			_Browser_window.addEventListener('popstate', key);
			_Browser_window.navigator.userAgent.indexOf('Trident') < 0 || _Browser_window.addEventListener('hashchange', key);

			return F2(function(domNode, event)
			{
				if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute('download'))
				{
					event.preventDefault();
					var href = domNode.href;
					var curr = _Browser_getUrl();
					var next = $elm$url$Url$fromString(href).a;
					sendToApp(impl.%onUrlRequest%(
						(next
							&& curr.%protocol% === next.%protocol%
							&& curr.%host% === next.%host%
							&& curr.%port_%.a === next.%port_%.a
						)
							? $elm$browser$Browser$Internal(next)
							: $elm$browser$Browser$External(href)
					));
				}
			});
		},
		%init%: function(flags)
		{
			// return A3(impl.init, flags, _Browser_getUrl(), key); // commented out by elm-watch
			return A3(impl.%init%, flags, window.__ELM_WATCH_INIT_URL, key); // added by elm-watch
		},
		// view: impl.view, // commented out by elm-watch
		// update: impl.update, // commented out by elm-watch
		// subscriptions: impl.subscriptions // commented out by elm-watch
		%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
		_impl: impl // added by elm-watch
	});
}
  `.trim(),
  $elm$browser$Browser$sandbox: `
// This function was slightly modified by elm-watch.
var $elm$browser$Browser$sandbox = function (impl) {
	return _Browser_element(
		{
			%init%: function (_v0) {
				return _Utils_Tuple2(impl.%init%, $elm$core$Platform$Cmd$none);
			},
			%subscriptions%: function (_v1) {
				return $elm$core$Platform$Sub$none;
			},
			%update%: F2(
				function (msg, model) {
					return _Utils_Tuple2(
						A2(impl.%update%, msg, model),
						$elm$core$Platform$Cmd$none);
				}),
			// view: impl.view // commented out by elm-watch
			%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
			_impl: impl // added by elm-watch
		});
};
  `.trim(),
  _Platform_worker: `
// This function was slightly modified by elm-watch.
var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		"Platform.worker", // added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function() { return function() {} }
	);
});
  `.trim(),
  _Browser_element: `
// This function was slightly modified by elm-watch.
var _Browser_element = _Debugger_element || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			// var view = impl.view; // commented out by elm-watch
			/**_UNUSED/ // always UNUSED with elm-watch
			var domNode = args['node'];
			//*/
			/**/
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			//*/
			var currNode = _VirtualDom_virtualize(domNode);

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = view(model); // commented out by elm-watch
				var nextNode = impl.%view%(model); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;
			});
		}
	);
});
  `.trim(),
  _Browser_document: `
// This function was slightly modified by elm-watch.
var _Browser_document = _Debugger_document || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			var divertHrefToApp = impl.%setup% && impl.%setup%(sendToApp)
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			var currNode = _VirtualDom_virtualize(bodyNode);
			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view(model); // commented out by elm-watch
				var doc = impl.%view%(model); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(doc.%body%);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.%title%) && (_VirtualDom_doc.title = title = doc.%title%);
			});
		}
	);
});
  `.trim(),
  _Debugger_element: `
// This function was slightly modified by elm-watch.
var _Debugger_element = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			var currNode = _VirtualDom_virtualize(domNode);
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			var cornerNode = _VirtualDom_doc.createElement('div');
			domNode.parentNode.insertBefore(cornerNode, domNode.nextSibling);
			var cornerCurr = _VirtualDom_virtualize(cornerNode);

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, view($elm$browser$Debugger$Main$getUserModel(model))); // commented out by elm-watch
				var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, impl.view($elm$browser$Debugger$Main$getUserModel(model))); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view corner

				var cornerNext = $elm$browser$Debugger$Main$cornerView(model);
				var cornerPatches = _VirtualDom_diff(cornerCurr, cornerNext);
				cornerNode = _VirtualDom_applyPatches(cornerNode, cornerCurr, cornerPatches, sendToApp);
				cornerCurr = cornerNext;

				if (!model.popout.b)
				{
					currPopout = undefined;
					return;
				}

				// view popout

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  _Debugger_document: `
// This function was slightly modified by elm-watch.
var _Debugger_document = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			var divertHrefToApp = impl.setup && impl.setup(function(x) { return sendToApp($elm$browser$Debugger$Main$UserMsg(x)); });
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			var currNode = _VirtualDom_virtualize(bodyNode);
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view($elm$browser$Debugger$Main$getUserModel(model)); // commented out by elm-watch
				var doc = impl.view($elm$browser$Debugger$Main$getUserModel(model)); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(
					_Utils_ap(
						A2($elm$core$List$map, _VirtualDom_map($elm$browser$Debugger$Main$UserMsg), doc.body),
						_List_Cons($elm$browser$Debugger$Main$cornerView(model), _List_Nil)
					)
				);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.title) && (_VirtualDom_doc.title = title = doc.title);

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view popout

				if (!model.popout.b) { currPopout = undefined; return; }

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b));
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  _Scheduler_binding: `
// This function was slightly modified by elm-watch.
function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		// c: null // commented out by elm-watch
		c: Function.prototype // added by elm-watch
	};
}
  `.trim(),
  _Scheduler_step: `
function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			// }); // commented out by elm-watch
			}) || Function.prototype; // added by elm-watch
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}
  `.trim()
};
var REPLACEMENTS_WITHOUT_PLACEHOLDERS = updateReplacements({}, REPLACEMENTS);
function inject(compilationMode, code) {
  const replacements = getReplacements(compilationMode, code);
  return code.replace(
    REPLACEMENT_REGEX,
    (match, name1, name = name1) => replacements[name] ?? `${match} /* elm-watch ERROR: No replacement for function '${name}' was found! */`
  );
}
function getReplacements(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return REPLACEMENTS_WITHOUT_PLACEHOLDERS;
    case "optimize":
      return updateReplacements(getOptimizeModeRecordNames(code), REPLACEMENTS);
  }
}
function getOptimizeModeRecordNames(code) {
  const match1 = /^\s*impl\.(\w+),\s*impl\.(\w+),\s*impl\.(\w+),/m.exec(code);
  const match2 = /^\s*var divertHrefToApp = impl\.(\w+)/m.exec(code);
  const match3 = /^\s*var nextNode = _VirtualDom_node\('body'\)\(_List_Nil\)\(doc\.(\w+)\);/m.exec(
    code
  );
  const match4 = /^\s*\(title !== doc\.(\w+)\)/m.exec(code);
  const match5 = /^\s*&& curr\.(\w+) .*\s*&& curr\.(\w+) .*\s*&& curr\.(\w+)\..*/m.exec(
    code
  );
  const [
    ,
    init3 = "init_missing",
    update2 = "update_missing",
    subscriptions = "subscriptions_missing"
  ] = match1 ?? [];
  const [, setup = "setup_missing"] = match2 ?? [];
  const [, body = "body_missing"] = match3 ?? [];
  const [, title = "title_missing"] = match4 ?? [];
  const [
    ,
    protocol = "protocol_missing",
    host = "host_missing",
    port_ = "port__missing"
  ] = match5 ?? [];
  const extra = Object.fromEntries(
    Array.from(
      code.matchAll(/^\s*var (\w+) = impl\.(\w+);/gm),
      ([, from = "from_missing", to = "to_missing"]) => [from, to]
    )
  );
  return {
    ...extra,
    init: init3,
    update: update2,
    subscriptions,
    setup,
    body,
    title,
    protocol,
    host,
    port_
  };
}
function updateReplacements(optimizeModeRecordNames, replacements) {
  return Object.fromEntries(
    Object.entries(replacements).map(([key, value]) => [
      key,
      updateString(optimizeModeRecordNames, value)
    ])
  );
}
function updateString(optimizeModeRecordNames, string6) {
  return string6.replace(
    PLACEHOLDER_REGEX,
    (_, name) => optimizeModeRecordNames[name] ?? name
  );
}
function proxyFile(outputPath, elmCompiledTimestamp, webSocketPort, debug) {
  return `${clientCode(
    outputPath,
    elmCompiledTimestamp,
    "proxy",
    webSocketPort,
    debug
  )}
${ClientCode.proxy}`;
}
function clientCode(outputPath, elmCompiledTimestamp, compilationMode, webSocketPort, debug) {
  const replacements = {
    TARGET_NAME: outputPath.targetName,
    INITIAL_ELM_COMPILED_TIMESTAMP: elmCompiledTimestamp.toString(),
    ORIGINAL_COMPILATION_MODE: compilationMode,
    WEBSOCKET_PORT: webSocketPort.thePort.toString(),
    DEBUG: debug.toString()
  };
  return versionedIdentifier(webSocketPort) + ClientCode.client.replace(
    new RegExp(`%(${join(Object.keys(replacements), "|")})%`, "g"),
    (match, name) => replacements[name] ?? match
  );
}
function versionedIdentifier(webSocketPort) {
  return `// elm-watch hot ${JSON.stringify({
    version: "1.0.2",
    webSocketPort: webSocketPort.thePort
  })}
`;
}
var RECORD_FIELD_REGEX = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?|\/\*(?:[^*]|\*(?!\/))*(\*\/)?|\/\/.*|\.[\w$]{1,4}\b/g;
function getRecordFields(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return void 0;
    case "optimize": {
      const matches = code.match(RECORD_FIELD_REGEX) ?? [];
      return new Set(matches.filter((string6) => string6.startsWith(".")));
    }
  }
}
function recordFieldsChanged(oldSet, newSet) {
  return !(oldSet === void 0 || newSet === void 0 || compareRecordFieldsHelper(oldSet) === compareRecordFieldsHelper(newSet));
}
function compareRecordFieldsHelper(set) {
  return Array.from(set).sort().join(",");
}

// src/Postprocess.ts
var path5 = require("path");
var import_worker_threads = require("worker_threads");

// src/Spawn.ts
var childProcess = require("child_process");
function spawn2(command) {
  let killed = false;
  let kill = () => {
    killed = true;
  };
  const promise = (actualSpawn) => new Promise((resolve3) => {
    if (killed) {
      resolve3({ tag: "Killed", command });
      return;
    }
    const child = actualSpawn(command.command, command.args, {
      ...command.options,
      cwd: command.options.cwd.absolutePath
    });
    const stdout = [];
    const stderr = [];
    child.on("error", (error) => {
      resolve3(
        error.code === "ENOENT" ? { tag: "CommandNotFoundError", command } : { tag: "OtherSpawnError", error, command }
      );
    });
    let stdinWriteError = void 0;
    child.stdin.on("error", (error) => {
      if (error.code === "EPIPE" || error.code === "EOF") {
        const result = {
          tag: "StdinWriteError",
          error,
          command
        };
        stdinWriteError = {
          result,
          timeoutId: setTimeout(
            () => {
              resolve3(result);
            },
            500
          )
        };
      } else {
        resolve3({ tag: "OtherSpawnError", error, command });
      }
    });
    child.stdout.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stderr.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    child.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    child.on("exit", (exitCode, signal) => {
      if (killed) {
      } else if (exitCode === 0 && stdinWriteError !== void 0) {
        clearTimeout(stdinWriteError.timeoutId);
        resolve3(stdinWriteError.result);
      } else {
        resolve3({
          tag: "Exit",
          exitReason: exitReason(exitCode, signal),
          stdout: Buffer.concat(stdout),
          stderr: Buffer.concat(stderr),
          command
        });
      }
    });
    kill = () => {
      if (!killed) {
        child.kill();
        resolve3({ tag: "Killed", command });
        killed = true;
      }
    };
    if (command.stdin !== void 0) {
      child.stdin.end(command.stdin);
    }
  });
  return {
    promise: IS_WINDOWS ? import("cross-spawn").then((crossSpawn) => promise(crossSpawn.spawn)) : promise(childProcess.spawn),
    kill: () => {
      kill();
    }
  };
}
function exitReason(exitCode, signal) {
  return exitCode !== null ? { tag: "ExitCode", exitCode } : signal !== null ? { tag: "Signal", signal } : { tag: "Unknown" };
}

// src/Postprocess.ts
function runPostprocess({
  env,
  elmWatchJsonPath,
  compilationMode,
  runMode,
  outputPath: output,
  postprocessArray,
  code,
  postprocessWorkerPool
}) {
  const commandName = postprocessArray[0];
  const userArgs = postprocessArray.slice(1);
  const cwd = absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath);
  if (commandName === ELM_WATCH_NODE) {
    const worker = postprocessWorkerPool.getOrCreateAvailableWorker();
    return {
      promise: worker.postprocess({
        cwd,
        code: code.toString("utf8"),
        targetName: output.targetName,
        compilationMode,
        runMode,
        userArgs
      }),
      kill: () => worker.terminate()
    };
  }
  const command = {
    command: commandName,
    args: [...userArgs, output.targetName, compilationMode, runMode],
    options: { cwd, env },
    stdin: code
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
      case "OtherSpawnError":
        return spawnResult;
      case "StdinWriteError":
        return {
          tag: "PostprocessStdinWriteError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        if (!(exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0)) {
          const stdout = spawnResult.stdout.toString("utf8");
          const stderr = spawnResult.stderr.toString("utf8");
          return {
            tag: "PostprocessNonZeroExit",
            exitReason: exitReason2,
            stdout,
            stderr,
            command
          };
        }
        return { tag: "Success", code: spawnResult.stdout };
      }
    }
  };
  return {
    promise: promise.then(handleSpawnResult),
    kill: () => {
      kill();
      return Promise.resolve();
    }
  };
}
var PostprocessWorkerPool = class {
  constructor(onUnexpectedError) {
    this.onUnexpectedError = onUnexpectedError;
    this.workers = /* @__PURE__ */ new Set();
    this.calculateMax = () => Infinity;
  }
  getSize() {
    return this.workers.size;
  }
  setCalculateMax(calculateMax) {
    this.calculateMax = calculateMax;
  }
  getOrCreateAvailableWorker() {
    const existingWorker = Array.from(this.workers).find(
      (worker) => worker.isIdle()
    );
    if (existingWorker === void 0) {
      const newWorker = new PostprocessWorker(
        this.onUnexpectedError,
        () => {
          this.limit().catch(this.onUnexpectedError);
        },
        (worker) => {
          this.workers.delete(worker);
        }
      );
      this.workers.add(newWorker);
      return newWorker;
    } else {
      return existingWorker;
    }
  }
  async limit() {
    const idle = Array.from(this.workers).filter((worker) => worker.isIdle());
    const toKill = this.workers.size - this.calculateMax();
    if (toKill > 0) {
      await Promise.all(
        idle.slice(-toKill).map((worker) => worker.terminate())
      );
    }
    return toKill;
  }
  async terminate() {
    await Promise.all(
      Array.from(this.workers).map((worker) => worker.terminate())
    );
  }
};
var PostprocessWorker = class {
  constructor(onUnexpectedError, onIdle, onTerminated) {
    this.onUnexpectedError = onUnexpectedError;
    this.onIdle = onIdle;
    this.onTerminated = onTerminated;
    this.worker = new import_worker_threads.Worker(path5.join(__dirname, "PostprocessWorker.js"), {
      stdout: true,
      stderr: true
    });
    this.status = { tag: "Idle" };
    const stdout = [];
    const stderr = [];
    this.worker.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    this.worker.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    this.worker.on("error", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("messageerror", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("exit", (exitCode) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(
          new Error(
            `PostprocessWorker unexpectedly exited, with exit code ${exitCode}.`
          )
        );
      }
    });
    this.worker.on("message", (message) => {
      switch (message.tag) {
        case "PostprocessDone":
          switch (this.status.tag) {
            case "Idle":
              this.terminate().catch(this.onUnexpectedError);
              this.onUnexpectedError(
                new Error(
                  `PostprocessWorker received a ${JSON.stringify(
                    message.tag
                  )} message from the worker. This should only happen when "Busy" but the status is "Idle".`
                )
              );
              break;
            case "Busy":
              switch (message.result.tag) {
                case "Resolve": {
                  const result = message.result.value;
                  this.status.resolve(
                    "stdout" in result ? {
                      ...result,
                      stdout: Buffer.concat(stdout).toString("utf8"),
                      stderr: Buffer.concat(stderr).toString("utf8")
                    } : result
                  );
                  break;
                }
                case "Reject":
                  this.status.reject(toError(message.result.error));
                  break;
              }
              this.status = { tag: "Idle" };
              this.onIdle(this);
              break;
            case "Terminated":
              break;
          }
          stdout.length = 0;
          stderr.length = 0;
      }
    });
  }
  postMessage(message) {
    this.worker.postMessage(message);
  }
  isIdle() {
    return this.status.tag === "Idle";
  }
  async postprocess(args) {
    switch (this.status.tag) {
      case "Idle":
        return new Promise((resolve3, reject) => {
          this.status = { tag: "Busy", resolve: resolve3, reject };
          this.postMessage({ tag: "StartPostprocess", args });
        });
      case "Busy":
      case "Terminated":
        throw new Error(
          `Cannot call PostprocessWorker#postprocess because \`this.status === ${JSON.stringify(
            this.status
          )}\` instead of the expected "Idle".`
        );
    }
  }
  async terminate() {
    switch (this.status.tag) {
      case "Idle":
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        break;
      case "Busy": {
        const { resolve: resolve3 } = this.status;
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        resolve3({ tag: "Killed" });
        break;
      }
      case "Terminated":
    }
  }
};

// src/SpawnElm.ts
var fs6 = require("fs");
var os2 = require("os");
function make({
  elmJsonPath,
  compilationMode,
  inputs,
  outputPath,
  env,
  getNow
}) {
  const command = {
    command: "elm",
    args: [
      "make",
      "--report=json",
      ...maybeToArray(compilationModeToArg(compilationMode)),
      `--output=${outputPathToAbsoluteString(outputPath)}`,
      ...inputs.map((inputPath) => inputPath.theInputPath.absolutePath)
    ],
    options: {
      cwd: absoluteDirname(elmJsonPath.theElmJsonPath),
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        const match = elmStuffErrorMessagePrefixRegex.exec(stderr);
        const elmStuffError = match?.[0];
        const potentialJson = elmStuffError === void 0 ? stderr : stderr.slice(elmStuffError.length);
        return exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stdout === "" && stderr === "" ? { tag: "Success" } : exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && stdout === "" && potentialJson.startsWith("{") ? parseElmMakeJson(command, potentialJson, elmStuffError?.trim()) : {
          tag: "UnexpectedElmMakeOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: () => {
      delayKill(startTime, getNow, env, kill);
    }
  };
}
function delayKill(startTime, getNow, env, kill) {
  const timeout = silentlyReadIntEnvValue(env[__ELM_WATCH_ELM_TIMEOUT], 1e4);
  const elapsed = getNow().getTime() - startTime;
  setTimeout(kill, Math.max(0, timeout - elapsed));
}
function compilationModeToArg(compilationMode) {
  switch (compilationMode) {
    case "standard":
      return void 0;
    case "debug":
      return "--debug";
    case "optimize":
      return "--optimize";
  }
}
function outputPathToAbsoluteString(outputPath) {
  switch (outputPath.tag) {
    case "OutputPath":
      return outputPath.writeToTemporaryDir ? outputPath.temporaryOutputPath.absolutePath : outputPath.theOutputPath.absolutePath;
    case "NullOutputPath":
      return "/dev/null";
  }
}
function maybeToArray(arg) {
  return arg === void 0 ? [] : [arg];
}
function parseElmMakeJson(command, jsonString, extraError) {
  let json;
  try {
    json = JSON.parse(jsonString.replace(/\t/g, "\\t"));
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmMakeJsonParseError",
      error,
      errorFilePath: tryWriteErrorFile({
        cwd: command.options.cwd,
        name: "ElmMakeJsonParseError",
        content: toPlainString(
          elmMakeJsonParseError(
            { tag: "NoLocation" },
            error,
            { tag: "ErrorFileBadContent", content: jsonString },
            command
          )
        ),
        hash: jsonString
      }),
      command
    };
  }
  try {
    return {
      tag: "ElmMakeError",
      error: ElmMakeError(json),
      extraError
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmMakeJsonParseError",
      error,
      errorFilePath: tryWriteErrorFile({
        cwd: command.options.cwd,
        name: "ElmMakeJsonParseError",
        content: toPlainString(
          elmMakeJsonParseError(
            { tag: "NoLocation" },
            error,
            {
              tag: "ErrorFileBadContent",
              content: JSON.stringify(json, null, 2)
            },
            command
          )
        ),
        hash: jsonString
      }),
      command
    };
  }
}
var elmJsonErrorMessageRegex = /^-- (.+) -+( elm\.json)?\r?\n([^]+)$/;
var elmStuffErrorMessagePrefixRegex = /^\+-+\r?\n(?:\|.*\r?\n)+\+-+\r?\n\r?\n/;
function install({
  elmJsonPath,
  env,
  getNow
}) {
  const dummy = absolutePathFromString(
    {
      tag: "AbsolutePath",
      absolutePath: env[__ELM_WATCH_TMP_DIR] ?? os2.tmpdir()
    },
    "ElmWatchDummy.elm"
  );
  try {
    fs6.writeFileSync(dummy.absolutePath, elmWatchDummy());
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      promise: Promise.resolve({
        tag: "CreatingDummyFailed",
        error
      }),
      kill: () => {
      }
    };
  }
  const command = {
    command: "elm",
    args: ["make", `--output=/dev/null`, dummy.absolutePath],
    options: {
      cwd: absoluteDirname(elmJsonPath.theElmJsonPath),
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stderr === "") {
          return {
            tag: "Success",
            elmInstallOutput: stdout.split(/\r?\n|\r/).filter((line) => line.startsWith("  ")).map((line) => ` ${line}`).join("\n").trimEnd()
          };
        }
        if (elmStuffErrorMessagePrefixRegex.test(stderr)) {
          return { tag: "ElmStuffError" };
        }
        const match = elmJsonErrorMessageRegex.exec(stderr);
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && match !== null) {
          const [, title, elmJson2, message] = match;
          if (elmJson2 !== void 0) {
            return { tag: "ElmJsonError" };
          }
          if (title !== void 0 && message !== void 0) {
            return {
              tag: "ElmInstallError",
              title,
              message
            };
          }
        }
        return {
          tag: "UnexpectedElmInstallOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: () => {
      delayKill(startTime, getNow, env, kill);
    }
  };
}
function elmWatchDummy() {
  return `
module ElmWatchDummy exposing (dummy)


dummy : ()
dummy =
    ()
  `.trim();
}

// src/Compile.ts
function installDependencies(env, logger, getNow, project) {
  let currentKill = void 0;
  const loadingMessageDelay = silentlyReadIntEnvValue(
    env[__ELM_WATCH_LOADING_MESSAGE_DELAY],
    100
  );
  const printStatusLineHelper = (emojiName, message, nonFancy) => printStatusLine({
    maxWidth: logger.config.columns,
    fancy: logger.config.fancy,
    isTTY: logger.config.isTTY,
    emojiName,
    string: logger.config.fancy ? message : `${message}: ${nonFancy}`
  });
  const continuation = async () => {
    const elmJsonsArray = Array.from(project.elmJsons);
    for (const [index, [elmJsonPath]] of elmJsonsArray.entries()) {
      const message = `Dependencies${index === 0 ? "" : ` (${index + 1}/${elmJsonsArray.length})`}`;
      const loadingMessage = printStatusLineHelper(
        "Busy",
        message,
        "in progress"
      );
      let didWriteLoadingMessage = false;
      const timeoutId = setTimeout(() => {
        logger.write(loadingMessage);
        didWriteLoadingMessage = true;
      }, loadingMessageDelay);
      const clearLoadingMessage = () => {
        if (didWriteLoadingMessage) {
          logger.moveCursor(0, -1);
          logger.clearLine(0);
        }
      };
      const onError = (error) => {
        clearLoadingMessage();
        logger.write(printStatusLineHelper("Error", message, "error"));
        logger.write("");
        logger.errorTemplate(error);
        return { tag: "Error" };
      };
      const { promise, kill } = install({ elmJsonPath, env, getNow });
      currentKill = kill;
      const result = await promise.finally(() => {
        currentKill = void 0;
      });
      clearTimeout(timeoutId);
      switch (result.tag) {
        case "ElmJsonError":
        case "ElmStuffError":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Skipped", message, "skipped"));
          }
          break;
        case "Killed":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Busy", message, "interrupted"));
          }
          return { tag: "Killed" };
        case "Success": {
          const gotOutput = result.elmInstallOutput !== "";
          if (didWriteLoadingMessage || gotOutput) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Success", message, "success"));
          }
          if (gotOutput) {
            logger.write(result.elmInstallOutput);
          }
          break;
        }
        case "CreatingDummyFailed":
          return onError(creatingDummyFailed(elmJsonPath, result.error));
        case "ElmNotFoundError":
          return onError(elmNotFoundError(elmJsonPath, result.command));
        case "OtherSpawnError":
          return onError(
            otherSpawnError(elmJsonPath, result.error, result.command)
          );
        case "ElmInstallError":
          return onError(
            elmInstallError(elmJsonPath, result.title, result.message)
          );
        case "UnexpectedElmInstallOutput":
          return onError(
            unexpectedElmInstallOutput(
              elmJsonPath,
              result.exitReason,
              result.stdout,
              result.stderr,
              result.command
            )
          );
      }
    }
    return { tag: "Success" };
  };
  return {
    promise: continuation(),
    kill: () => {
      if (currentKill !== void 0) {
        currentKill();
      }
    }
  };
}
function getOutputActions({
  project,
  runMode,
  includeInterrupted,
  prioritizedOutputs
}) {
  let index = 0;
  let numExecuting = 0;
  let numInterrupted = 0;
  let numErrors = 0;
  const elmMakeActions = [];
  const elmMakeTypecheckOnlyActions = [];
  const postprocessActions = [];
  const outputsWithoutAction = [];
  const busyElmJsons = new HashSet();
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    const typecheckOnly = [];
    for (const [outputPath, outputState] of outputs) {
      const output = {
        index,
        elmJsonPath,
        outputPath,
        outputState
      };
      index++;
      const priority = prioritizedOutputs === "AllEqualPriority" ? 0 : prioritizedOutputs.get(outputPath);
      const needsElm = (source) => {
        if (priority !== void 0) {
          elmMakeActions.push({
            tag: "NeedsElmMake",
            elmJsonPath,
            output,
            source,
            priority
          });
        } else {
          typecheckOnly.push({ output, source });
        }
      };
      switch (outputState.status.tag) {
        case "ElmMake":
        case "ElmMakeTypecheckOnly":
          numExecuting++;
          outputsWithoutAction.push(output);
          busyElmJsons.add(elmJsonPath);
          break;
        case "Postprocess":
          numExecuting++;
          outputsWithoutAction.push(output);
          break;
        case "QueuedForElmMake":
          needsElm("Queued");
          break;
        case "QueuedForPostprocess":
          postprocessActions.push({
            tag: "NeedsPostprocess",
            output,
            postprocessArray: outputState.status.postprocessArray,
            priority: priority ?? 0,
            code: outputState.status.code,
            elmCompiledTimestamp: outputState.status.elmCompiledTimestamp,
            recordFields: outputState.status.recordFields
          });
          break;
        case "Interrupted":
          numInterrupted++;
          if (includeInterrupted) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        case "Success":
        case "NotWrittenToDisk":
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        default: {
          const _ = outputState.status;
          numErrors++;
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        }
      }
    }
    if (isNonEmptyArray(typecheckOnly)) {
      elmMakeTypecheckOnlyActions.push({
        tag: "NeedsElmMakeTypecheckOnly",
        elmJsonPath,
        outputs: typecheckOnly
      });
    }
  }
  const prioritizedActions = prioritizeActions(
    runMode,
    elmMakeActions,
    elmMakeTypecheckOnlyActions,
    postprocessActions
  );
  const actions = [];
  const queueActions = [];
  const threadsLeft = Math.max(0, project.maxParallel - numExecuting);
  for (const action of prioritizedActions) {
    switch (action.tag) {
      case "NeedsElmMake":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          switch (action.source) {
            case "Dirty":
              queueActions.push({
                tag: "QueueForElmMake",
                output: action.output
              });
              break;
            case "Queued":
              outputsWithoutAction.push(action.output);
              break;
          }
        }
        break;
      case "NeedsElmMakeTypecheckOnly":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          for (const { output, source } of action.outputs) {
            switch (source) {
              case "Dirty":
                queueActions.push({
                  tag: "QueueForElmMake",
                  output
                });
                break;
              case "Queued":
                outputsWithoutAction.push(output);
                break;
            }
          }
        }
        break;
      case "NeedsPostprocess":
        if (actions.length < threadsLeft) {
          actions.push(action);
        } else {
          outputsWithoutAction.push(action.output);
        }
        break;
    }
  }
  return {
    total: index,
    numExecuting,
    numInterrupted,
    numErrors,
    actions: [...actions, ...queueActions],
    outputsWithoutAction
  };
}
function prioritizeActions(runMode, elmMakeActions, elmMakeTypecheckOnlyActions, postprocessActions) {
  switch (runMode) {
    case "make":
      return [
        ...elmMakeActions,
        ...elmMakeTypecheckOnlyActions,
        ...postprocessActions
      ];
    case "hot":
      return [
        ...sortByPriority(postprocessActions),
        ...sortByPriority(elmMakeActions),
        ...elmMakeTypecheckOnlyActions
      ];
  }
}
function sortByPriority(array3) {
  return array3.slice().sort((a, b) => b.priority - a.priority);
}
async function handleOutputAction({
  env,
  logger,
  getNow,
  runMode,
  elmWatchJsonPath,
  total,
  action,
  postprocess,
  postprocessWorkerPool
}) {
  switch (action.tag) {
    case "NeedsElmMake":
      return compileOneOutput({
        env,
        logger,
        getNow,
        runMode,
        total,
        ...action.output,
        postprocess
      });
    case "NeedsElmMakeTypecheckOnly":
      switch (runMode.tag) {
        case "make":
          throw new Error(
            `Got NeedsElmMakeTypecheckOnly in \`make\` mode!
${JSON.stringify(
              action,
              null,
              2
            )}`
          );
        case "hot":
          await typecheck({
            env,
            logger,
            getNow,
            runMode: runMode.tag,
            elmJsonPath: action.elmJsonPath,
            outputs: mapNonEmptyArray(action.outputs, ({ output }) => output),
            total,
            webSocketPort: runMode.webSocketPort
          });
          return { tag: "Nothing" };
      }
    case "NeedsPostprocess":
      return postprocessHelper({
        env,
        logger,
        runMode,
        elmWatchJsonPath,
        total,
        ...action.output,
        postprocessArray: action.postprocessArray,
        postprocessWorkerPool,
        code: action.code,
        elmCompiledTimestamp: action.elmCompiledTimestamp,
        recordFields: action.recordFields
      });
    case "QueueForElmMake":
      action.output.outputState.setStatus({ tag: "QueuedForElmMake" });
      updateStatusLine({
        logger,
        runMode: runMode.tag,
        total,
        ...action.output
      });
      return { tag: "Nothing" };
  }
}
async function compileOneOutput({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocess
}) {
  const startTimestamp = getNow().getTime();
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  outputState.dirty = false;
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: outputState.compilationMode,
    inputs: outputState.inputs,
    outputPath: {
      ...outputPath,
      writeToTemporaryDir: !(runMode.tag === "make" && postprocess.tag === "NoPostprocess")
    },
    env,
    getNow
  });
  const outputStatus = {
    tag: "ElmMake",
    compilationMode: outputState.compilationMode,
    elmDurationMs: -1,
    walkerDurationMs: -1,
    injectDurationMs: -1,
    kill
  };
  outputState.setStatus(outputStatus);
  updateStatusLineHelper();
  const [elmMakeResult, allRelatedElmFilePathsResult] = await Promise.all([
    promise.then((result) => {
      outputStatus.elmDurationMs = getNow().getTime() - startTimestamp;
      return result;
    }),
    Promise.resolve().then(() => {
      switch (runMode.tag) {
        case "make":
          return {
            tag: "Success",
            allRelatedElmFilePaths: outputState.allRelatedElmFilePaths
          };
        case "hot": {
          const result = getAllRelatedElmFilePaths(
            elmJsonPath,
            outputState.inputs
          );
          outputStatus.walkerDurationMs = getNow().getTime() - startTimestamp;
          return result;
        }
      }
    })
  ]);
  if (outputState.dirty || elmMakeResult.tag === "Killed") {
    outputState.setStatus({ tag: "Interrupted" });
    updateStatusLineHelper();
    return { tag: "Nothing" };
  }
  outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
    allRelatedElmFilePathsResult,
    outputState
  );
  const combinedResult = combineResults(
    elmMakeResult,
    allRelatedElmFilePathsResult
  );
  switch (combinedResult.tag) {
    case "elm make success + walker success":
      return onCompileSuccess(
        logger.config,
        getNow,
        updateStatusLineHelper,
        runMode,
        outputPath,
        outputState,
        outputStatus,
        postprocess
      );
    case "elm make success + walker failure":
      outputState.setStatus(combinedResult.walkerError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        outputPath,
        compilationMode: outputState.compilationMode
      };
    case "elm make failure + walker success":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        outputPath,
        compilationMode: outputState.compilationMode
      };
    case "elm make failure + walker failure":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        outputPath,
        compilationMode: outputState.compilationMode
      };
  }
}
function onCompileSuccess(loggerConfig, getNow, updateStatusLineHelper, runMode, outputPath, outputState, outputStatus, postprocess) {
  const elmCompiledTimestamp = getNow().getTime();
  switch (runMode.tag) {
    case "make":
      switch (postprocess.tag) {
        case "NoPostprocess": {
          let fileSize;
          try {
            fileSize = fs7.statSync(outputPath.theOutputPath.absolutePath).size;
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.theOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              outputPath,
              compilationMode: outputState.compilationMode
            };
          }
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
        case "Postprocess": {
          let buffer;
          try {
            buffer = fs7.readFileSync(
              outputPath.temporaryOutputPath.absolutePath
            );
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.temporaryOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              outputPath,
              compilationMode: outputState.compilationMode
            };
          }
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: buffer,
            elmCompiledTimestamp,
            recordFields: void 0
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    case "hot": {
      let code;
      try {
        code = fs7.readFileSync(
          outputPath.temporaryOutputPath.absolutePath,
          "utf8"
        );
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "ReadOutputError",
          error,
          triedPath: outputPath.temporaryOutputPath
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          outputPath,
          compilationMode: outputState.compilationMode
        };
      }
      const recordFields = getRecordFields(
        outputState.compilationMode,
        code
      );
      const newCode = inject(outputState.compilationMode, code);
      outputStatus.injectDurationMs = getNow().getTime() - elmCompiledTimestamp;
      switch (postprocess.tag) {
        case "NoPostprocess": {
          try {
            fs7.mkdirSync(
              absoluteDirname(outputPath.theOutputPath).absolutePath,
              { recursive: true }
            );
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              clientCode(
                outputPath,
                elmCompiledTimestamp,
                outputState.compilationMode,
                runMode.webSocketPort,
                loggerConfig.debug
              ) + newCode
            );
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "WriteOutputError",
              error,
              reasonForWriting: "InjectWebSocketClient"
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              outputPath,
              compilationMode: outputState.compilationMode
            };
          }
          const recordFieldsChanged2 = recordFieldsChanged(
            outputState.recordFields,
            recordFields
          );
          const fileSize = Buffer.byteLength(newCode);
          outputState.recordFields = recordFields;
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return recordFieldsChanged2 ? {
            tag: "FullyCompiledJSButRecordFieldsChanged",
            outputPath
          } : {
            tag: "FullyCompiledJS",
            outputPath,
            code: newCode,
            elmCompiledTimestamp,
            compilationMode: outputState.compilationMode
          };
        }
        case "Postprocess": {
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: newCode,
            elmCompiledTimestamp,
            recordFields
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    }
  }
}
function needsToWriteProxyFile(outputPath, versionedIdentifier2) {
  let handle;
  try {
    handle = fs7.openSync(outputPath.absolutePath, "r");
  } catch (unknownError) {
    const error = toError(unknownError);
    return error.code === "ENOENT" ? { tag: "Needed" } : { tag: "ReadError", error };
  }
  const buffer = Buffer.alloc(versionedIdentifier2.byteLength);
  try {
    fs7.readSync(handle, buffer);
  } catch (unknownError) {
    const error = toError(unknownError);
    return { tag: "ReadError", error };
  }
  return buffer.equals(versionedIdentifier2) ? { tag: "NotNeeded" } : { tag: "Needed" };
}
async function postprocessHelper({
  env,
  logger,
  runMode,
  elmWatchJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocessArray,
  postprocessWorkerPool,
  code,
  elmCompiledTimestamp,
  recordFields
}) {
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  const { promise, kill } = runPostprocess({
    env,
    elmWatchJsonPath,
    compilationMode: outputState.compilationMode,
    runMode: runMode.tag,
    outputPath,
    postprocessArray,
    postprocessWorkerPool,
    code
  });
  outputState.setStatus({ tag: "Postprocess", kill });
  updateStatusLineHelper();
  const postprocessResult = await promise;
  switch (postprocessResult.tag) {
    case "Killed":
      outputState.dirty = true;
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLineHelper();
      return { tag: "Nothing" };
    case "Success": {
      try {
        fs7.mkdirSync(absoluteDirname(outputPath.theOutputPath).absolutePath, {
          recursive: true
        });
        switch (runMode.tag) {
          case "make":
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              postprocessResult.code
            );
            break;
          case "hot": {
            const clientCode2 = clientCode(
              outputPath,
              elmCompiledTimestamp,
              outputState.compilationMode,
              runMode.webSocketPort,
              logger.config.debug
            );
            fs7.writeFileSync(
              outputPath.theOutputPath.absolutePath,
              typeof postprocessResult.code === "string" ? clientCode2 + postprocessResult.code : Buffer.concat([
                Buffer.from(clientCode2),
                postprocessResult.code
              ])
            );
            break;
          }
        }
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "WriteOutputError",
          error,
          reasonForWriting: "Postprocess"
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          outputPath,
          compilationMode: outputState.compilationMode
        };
      }
      const recordFieldsChanged2 = recordFieldsChanged(
        outputState.recordFields,
        recordFields
      );
      outputState.recordFields = recordFields;
      outputState.setStatus({
        tag: "Success",
        elmFileSize: Buffer.byteLength(code),
        postprocessFileSize: Buffer.byteLength(postprocessResult.code),
        elmCompiledTimestamp
      });
      updateStatusLineHelper();
      return recordFieldsChanged2 ? {
        tag: "FullyCompiledJSButRecordFieldsChanged",
        outputPath
      } : {
        tag: "FullyCompiledJS",
        outputPath,
        code: postprocessResult.code,
        elmCompiledTimestamp,
        compilationMode: outputState.compilationMode
      };
    }
    default:
      outputState.setStatus(postprocessResult);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        outputPath,
        compilationMode: outputState.compilationMode
      };
  }
}
async function typecheck({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputs,
  total,
  webSocketPort
}) {
  const startTimestamp = getNow().getTime();
  const outputsWithStatus = [];
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: "standard",
    inputs: nonEmptyArrayUniqueBy(
      (inputPath) => inputPath.realpath.absolutePath,
      flattenNonEmptyArray(
        mapNonEmptyArray(outputs, ({ outputState }) => outputState.inputs)
      )
    ),
    outputPath: { tag: "NullOutputPath" },
    env,
    getNow
  });
  for (const output of outputs) {
    const outputStatus = {
      tag: "ElmMakeTypecheckOnly",
      elmDurationMs: -1,
      walkerDurationMs: -1,
      kill
    };
    outputsWithStatus.push({ ...output, outputStatus });
    output.outputState.dirty = false;
    output.outputState.setStatus(outputStatus);
    updateStatusLine({
      logger,
      runMode,
      outputPath: output.outputPath,
      outputState: output.outputState,
      index: output.index,
      total
    });
  }
  const [elmMakeResult, allRelatedElmFilePathsResults] = await Promise.all([
    promise.then((result) => {
      const durationMs = getNow().getTime() - startTimestamp;
      for (const output of outputsWithStatus) {
        output.outputStatus.elmDurationMs = durationMs;
      }
      return result;
    }),
    Promise.resolve().then(
      () => outputsWithStatus.map(
        (output) => {
          const thisStartTimestamp = getNow().getTime();
          const allRelatedElmFilePathsResult = getAllRelatedElmFilePaths(
            elmJsonPath,
            output.outputState.inputs
          );
          output.outputStatus.walkerDurationMs = getNow().getTime() - thisStartTimestamp;
          return {
            ...output,
            allRelatedElmFilePathsResult
          };
        }
      )
    )
  ]);
  for (const {
    index,
    outputPath,
    outputState,
    allRelatedElmFilePathsResult
  } of allRelatedElmFilePathsResults) {
    if (outputState.dirty || elmMakeResult.tag === "Killed") {
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLine({
        logger,
        runMode,
        outputPath,
        outputState,
        index,
        total
      });
      continue;
    }
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      allRelatedElmFilePathsResult,
      outputState
    );
    const combinedResult = combineResults(
      onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult),
      allRelatedElmFilePathsResult
    );
    const proxyFileResult = needsToWriteProxyFile(
      outputPath.theOutputPath,
      Buffer.from(versionedIdentifier(webSocketPort))
    );
    switch (proxyFileResult.tag) {
      case "Needed":
        try {
          fs7.mkdirSync(absoluteDirname(outputPath.theOutputPath).absolutePath, {
            recursive: true
          });
          fs7.writeFileSync(
            outputPath.theOutputPath.absolutePath,
            proxyFile(
              outputPath,
              getNow().getTime(),
              webSocketPort,
              logger.config.debug
            )
          );
          outputState.setStatus({ tag: "NotWrittenToDisk" });
        } catch (unknownError) {
          const error = toError(unknownError);
          outputState.setStatus({ tag: "WriteProxyOutputError", error });
        }
        break;
      case "NotNeeded":
        outputState.setStatus({ tag: "NotWrittenToDisk" });
        break;
      case "ReadError":
        outputState.setStatus({
          tag: "ReadOutputError",
          error: proxyFileResult.error,
          triedPath: outputPath.theOutputPath
        });
        break;
    }
    switch (combinedResult.tag) {
      case "elm make success + walker success":
        break;
      case "elm make success + walker failure":
        outputState.setStatus(combinedResult.walkerError);
        break;
      case "elm make failure + walker success":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
      case "elm make failure + walker failure":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
    }
    updateStatusLine({
      logger,
      runMode,
      outputPath,
      outputState,
      index,
      total
    });
  }
}
function onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult) {
  if (!(elmMakeResult.tag === "ElmMakeError" && elmMakeResult.error.tag === "CompileErrors")) {
    return elmMakeResult;
  }
  const errors = elmMakeResult.error.errors.filter(
    (error) => outputState.allRelatedElmFilePaths.has(error.path.absolutePath)
  );
  return isNonEmptyArray(errors) ? {
    tag: "ElmMakeError",
    error: { tag: "CompileErrors", errors },
    extraError: elmMakeResult.extraError
  } : { tag: "Success" };
}
function combineResults(elmMakeResult, allRelatedElmFilePathsResult) {
  switch (elmMakeResult.tag) {
    case "Success":
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make success + walker success",
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make success + walker failure",
            walkerError: allRelatedElmFilePathsResult
          };
      }
    default:
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make failure + walker success",
            elmMakeError: elmMakeResult,
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make failure + walker failure",
            elmMakeError: elmMakeResult,
            walkerError: allRelatedElmFilePathsResult
          };
      }
  }
}
function printSpaceForOutputs(logger, runMode, outputActions) {
  if (!logger.config.isTTY) {
    return;
  }
  if (isNonEmptyArray(outputActions.outputsWithoutAction)) {
    for (let index = 0; index < outputActions.total; index++) {
      const output = outputActions.outputsWithoutAction.find(
        (output2) => output2.index === index
      );
      if (output === void 0) {
        writeNewLines(logger, 1);
      } else {
        logger.write(
          statusLine(
            logger.config,
            runMode,
            output.outputPath,
            output.outputState
          )
        );
      }
    }
  } else {
    writeNewLines(logger, outputActions.total);
  }
}
function writeNewLines(logger, count) {
  if (count > 0) {
    logger.write("\n".repeat(count - 1));
  }
}
function updateStatusLine({
  logger,
  runMode,
  outputPath,
  outputState,
  index,
  total
}) {
  logger.moveCursor(0, -total + index);
  logger.clearLine(0);
  logger.write(statusLine(logger.config, runMode, outputPath, outputState));
  logger.moveCursor(0, total - index - 1);
}
var EMOJI = {
  QueuedForElmMake: {
    emoji: "\u26AA\uFE0F",
    description: "queued for elm make"
  },
  QueuedForPostprocess: {
    emoji: "\u{1F7E2}",
    description: "elm make done \u2013 queued for postprocess"
  },
  Busy: {
    emoji: "\u23F3",
    description: "elm make or postprocess"
  },
  Error: {
    emoji: "\u{1F6A8}",
    description: "error"
  },
  Skipped: {
    emoji: "\u26D4\uFE0F",
    description: "skipped"
  },
  Success: {
    emoji: "\u2705",
    description: "success"
  },
  Information: {
    emoji: "\u2139\uFE0F",
    description: "info"
  },
  Stats: {
    emoji: "\u{1F4CA}",
    description: "stats"
  }
};
function emojiWidthFix({
  emoji,
  column,
  isTTY
}) {
  return `${emoji}${isTTY ? cursorHorizontalAbsolute(column) : ""}`;
}
var GOOD_ENOUGH_STARTS_WITH_EMOJI_REGEX = /^(?:\p{Other_Symbol}[\u{1f3fb}-\u{1f3ff}]?\ufe0f?|[🇦-🇿]{2}) /u;
function targetNameEmojiTweak(loggerConfig, targetName) {
  const match = GOOD_ENOUGH_STARTS_WITH_EMOJI_REGEX.exec(targetName);
  if (match === null) {
    return { targetName, delta: 0 };
  }
  const content = match[0] ?? "";
  if (!loggerConfig.fancy) {
    return { targetName: targetName.slice(content.length), delta: 0 };
  }
  const start = emojiWidthFix({
    emoji: content.trim(),
    column: 6,
    isTTY: loggerConfig.isTTY
  });
  return {
    targetName: `${start} ${targetName.slice(content.length)}`,
    delta: -start.length + 2
  };
}
function printStatusLinesForElmJsonsErrors(logger, project) {
  for (const { outputPath } of project.elmJsonsErrors) {
    const { targetName, delta } = targetNameEmojiTweak(
      logger.config,
      outputPath.targetName
    );
    logger.write(
      printStatusLine({
        maxWidth: logger.config.columns - delta,
        fancy: logger.config.fancy,
        isTTY: logger.config.isTTY,
        emojiName: "Error",
        string: logger.config.fancy ? targetName : `${targetName}: error`
      })
    );
  }
}
function printErrors(logger, errors) {
  const errorStrings = Array.from(
    new Set(errors.map((template) => template(logger.config.columns)))
  );
  logger.write("");
  logger.write(join(errorStrings, "\n\n"));
  logger.write("");
  printNumErrors(logger, errorStrings.length);
}
function printNumErrors(logger, numErrors) {
  logger.write(
    printStatusLine({
      maxWidth: logger.config.columns,
      fancy: logger.config.fancy,
      isTTY: logger.config.isTTY,
      emojiName: "Error",
      string: `${bold(numErrors.toString())} error${numErrors === 1 ? "" : "s"} found`
    })
  );
}
function statusLine(loggerConfig, runMode, outputPath, outputState) {
  const { status } = outputState;
  const { targetName, delta } = targetNameEmojiTweak(
    loggerConfig,
    outputPath.targetName
  );
  const helper = (emojiName, string6) => printStatusLine({
    maxWidth: loggerConfig.columns - delta,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: string6
  });
  const withExtraDetailsAtEnd = (extra, emojiName, start) => {
    const strings = extra.flatMap((item) => item === void 0 ? [] : item);
    if (!isNonEmptyArray(strings)) {
      return helper(emojiName, start);
    }
    const startLength = (loggerConfig.fancy ? start.length + 3 : start.length) + delta;
    const end = join(strings, "   ");
    const max = Math.min(loggerConfig.columns, 100);
    const padding = loggerConfig.isTTY ? Math.max(3, max - end.length - startLength) : 3;
    return helper(
      emojiName,
      `${start}\0${" ".repeat(padding - 1)}${end}`
    ).replace(/\0(.*)$/, dim(" $1"));
  };
  switch (status.tag) {
    case "NotWrittenToDisk": {
      return withExtraDetailsAtEnd(
        [maybePrintDurations(loggerConfig, outputState.flushDurations())],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "Success": {
      return withExtraDetailsAtEnd(
        [
          maybePrintFileSize({
            runMode,
            compilationMode: outputState.compilationMode,
            elmFileSize: status.elmFileSize,
            postprocessFileSize: status.postprocessFileSize,
            fancy: loggerConfig.fancy
          }),
          maybePrintDurations(loggerConfig, outputState.flushDurations())
        ],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "ElmMake": {
      const arg = compilationModeToArg(status.compilationMode);
      const flags = arg === void 0 ? "" : ` ${arg}`;
      return helper("Busy", `${targetName}: elm make${flags}`);
    }
    case "ElmMakeTypecheckOnly":
      return helper("Busy", `${targetName}: elm make (typecheck only)`);
    case "Postprocess":
      return helper("Busy", `${targetName}: postprocess`);
    case "Interrupted":
      return helper("Busy", `${targetName}: interrupted`);
    case "QueuedForElmMake":
      return helper("QueuedForElmMake", `${targetName}: queued`);
    case "QueuedForPostprocess":
      return helper("QueuedForPostprocess", `${targetName}: elm make done`);
    case "ElmNotFoundError":
    case "CommandNotFoundError":
    case "OtherSpawnError":
    case "UnexpectedElmMakeOutput":
    case "PostprocessStdinWriteError":
    case "PostprocessNonZeroExit":
    case "ElmWatchNodeMissingScript":
    case "ElmWatchNodeImportError":
    case "ElmWatchNodeDefaultExportNotFunction":
    case "ElmWatchNodeRunError":
    case "ElmWatchNodeBadReturnValue":
    case "ElmMakeJsonParseError":
    case "ElmMakeError":
    case "ElmJsonReadAsJsonError":
    case "ElmJsonDecodeError":
    case "ImportWalkerFileSystemError":
    case "ReadOutputError":
    case "WriteOutputError":
    case "WriteProxyOutputError":
      return helper(
        "Error",
        loggerConfig.fancy ? targetName : `${targetName}: error`
      );
  }
}
function printStatusLine({
  maxWidth,
  fancy,
  isTTY,
  emojiName,
  string: string6
}) {
  const emojiString = emojiWidthFix({
    emoji: EMOJI[emojiName].emoji,
    column: 3,
    isTTY
  });
  const stringWithEmoji = fancy ? `${emojiString} ${string6}` : string6;
  if (!isTTY) {
    return stringWithEmoji;
  }
  const length = fancy ? string6.length + 3 : string6.length;
  return length <= maxWidth ? stringWithEmoji : fancy ? `${emojiString} ${string6.slice(0, maxWidth - 4)}\u2026` : `${string6.slice(0, maxWidth - 3)}...`;
}
function maybePrintFileSize({
  runMode,
  compilationMode,
  elmFileSize,
  postprocessFileSize,
  fancy
}) {
  switch (runMode) {
    case "make":
      switch (compilationMode) {
        case "debug":
        case "standard":
          return void 0;
        case "optimize":
          return postprocessFileSize === elmFileSize ? printFileSize(elmFileSize) : `${printFileSize(elmFileSize)} ${fancy ? "\u2192" : "->"} ${printFileSize(postprocessFileSize)} (${(postprocessFileSize / elmFileSize * 100).toFixed(1)} %)`;
      }
    case "hot":
      return void 0;
  }
}
function maybePrintDurations(loggerConfig, durations) {
  if (!isNonEmptyArray(durations)) {
    return void 0;
  }
  const newDurations = durations.some(
    (duration) => duration.tag === "QueuedForElmMake"
  ) ? durations : [{ tag: "QueuedForElmMake", durationMs: 0 }, ...durations];
  return join(
    mapNonEmptyArray(
      newDurations,
      (duration) => printDuration(
        loggerConfig.mockedTimings ? mockDuration(duration) : duration,
        loggerConfig.fancy
      )
    ),
    " | "
  );
}
function printDuration(duration, fancy) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return `${printDurationMs(duration.durationMs)} Q`;
    case "ElmMake":
    case "ElmMakeTypecheckOnly":
      return `${printDurationMs(duration.elmDurationMs)} ${duration.tag === "ElmMake" ? "E" : "T"}${duration.walkerDurationMs === -1 ? "" : ` ${fancy ? "\xA6" : "/"} ${printDurationMs(
        duration.walkerDurationMs
      )} W`}`;
    case "Inject":
      return `${printDurationMs(duration.durationMs)} I`;
    case "QueuedForPostprocess":
      return `${printDurationMs(duration.durationMs)} R`;
    case "Postprocess":
      return `${printDurationMs(duration.durationMs)} P`;
  }
}
function mockDuration(duration) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return {
        tag: "QueuedForElmMake",
        durationMs: 1
      };
    case "ElmMake":
      return {
        tag: "ElmMake",
        elmDurationMs: 1234,
        walkerDurationMs: duration.walkerDurationMs === -1 ? -1 : 55
      };
    case "ElmMakeTypecheckOnly":
      return {
        tag: "ElmMakeTypecheckOnly",
        elmDurationMs: 765,
        walkerDurationMs: 50
      };
    case "Inject":
      return {
        tag: "Inject",
        durationMs: 9
      };
    case "QueuedForPostprocess":
      return {
        tag: "QueuedForPostprocess",
        durationMs: 0
      };
    case "Postprocess":
      return {
        tag: "Postprocess",
        durationMs: 31234
      };
  }
}
function extractErrors(project) {
  return [
    ...project.elmJsonsErrors.map(({ outputPath, error }) => {
      switch (error.tag) {
        case "ElmJsonNotFound":
          return elmJsonNotFound(
            outputPath,
            error.elmJsonNotFound,
            error.foundElmJsonPaths
          );
        case "NonUniqueElmJsonPaths":
          return nonUniqueElmJsonPaths(
            outputPath,
            error.nonUniqueElmJsonPaths
          );
        case "InputsNotFound":
          return inputsNotFound(outputPath, error.inputsNotFound);
        case "InputsFailedToResolve":
          return inputsFailedToResolve(
            outputPath,
            error.inputsFailedToResolve
          );
        case "DuplicateInputs":
          return duplicateInputs(outputPath, error.duplicates);
      }
    }),
    ...Array.from(project.elmJsons).flatMap(
      ([elmJsonPath, outputs]) => Array.from(outputs).flatMap(([outputPath, { status }]) => {
        switch (status.tag) {
          case "NotWrittenToDisk":
            return [];
          case "ElmMake":
          case "ElmMakeTypecheckOnly":
          case "Postprocess":
          case "Interrupted":
          case "QueuedForElmMake":
            return stuckInProgressState(outputPath, status.tag);
          case "QueuedForPostprocess":
            return [];
          case "Success":
            return [];
          case "ElmNotFoundError":
            return elmNotFoundError(outputPath, status.command);
          case "CommandNotFoundError":
            return commandNotFoundError(outputPath, status.command);
          case "OtherSpawnError":
            return otherSpawnError(
              outputPath,
              status.error,
              status.command
            );
          case "UnexpectedElmMakeOutput":
            return unexpectedElmMakeOutput(
              outputPath,
              status.exitReason,
              status.stdout,
              status.stderr,
              status.command
            );
          case "PostprocessStdinWriteError":
            return postprocessStdinWriteError(
              outputPath,
              status.error,
              status.command
            );
          case "PostprocessNonZeroExit":
            return postprocessNonZeroExit(
              outputPath,
              status.exitReason,
              status.stdout,
              status.stderr,
              status.command
            );
          case "ElmWatchNodeMissingScript":
            return elmWatchNodeMissingScript(project.elmWatchJsonPath);
          case "ElmWatchNodeImportError":
            return elmWatchNodeImportError(
              status.scriptPath,
              status.error,
              status.stdout,
              status.stderr
            );
          case "ElmWatchNodeDefaultExportNotFunction":
            return elmWatchNodeDefaultExportNotFunction(
              status.scriptPath,
              status.imported,
              status.typeofDefault,
              status.stdout,
              status.stderr
            );
          case "ElmWatchNodeRunError":
            return elmWatchNodeRunError(
              status.scriptPath,
              status.args,
              status.error,
              status.stdout,
              status.stderr
            );
          case "ElmWatchNodeBadReturnValue":
            return elmWatchNodeBadReturnValue(
              status.scriptPath,
              status.args,
              status.returnValue,
              status.stdout,
              status.stderr
            );
          case "ElmMakeJsonParseError":
            return elmMakeJsonParseError(
              outputPath,
              status.error,
              status.errorFilePath,
              status.command
            );
          case "ElmMakeError":
            switch (status.error.tag) {
              case "GeneralError":
                return renderGeneralError(
                  outputPath,
                  elmJsonPath,
                  status.error,
                  status.extraError
                );
              case "CompileErrors":
                return status.error.errors.flatMap(
                  (error) => error.problems.map(
                    (problem) => renderProblem(
                      error.path,
                      problem,
                      status.extraError
                    )
                  )
                );
            }
          case "ElmJsonReadAsJsonError":
            return readElmJsonAsJson(status.elmJsonPath, status.error);
          case "ElmJsonDecodeError":
            return decodeElmJson(status.elmJsonPath, status.error);
          case "ImportWalkerFileSystemError":
            return importWalkerFileSystemError(outputPath, status.error);
          case "ReadOutputError":
            return readOutputError(
              outputPath,
              status.error,
              status.triedPath
            );
          case "WriteOutputError":
            return writeOutputError(
              outputPath,
              status.error,
              status.reasonForWriting
            );
          case "WriteProxyOutputError":
            return writeProxyOutputError(outputPath, status.error);
        }
      })
    )
  ];
}
function getAllRelatedElmFilePaths(elmJsonPath, inputs) {
  const parseResult = readAndParse(elmJsonPath);
  switch (parseResult.tag) {
    case "Parsed":
      return walkImports(
        getSourceDirectories(elmJsonPath, parseResult.elmJson),
        inputs
      );
    default:
      return parseResult;
  }
}
function allRelatedElmFilePathsWithFallback(walkerResult, outputState) {
  switch (walkerResult.tag) {
    case "Success":
      return walkerResult.allRelatedElmFilePaths;
    case "ImportWalkerFileSystemError":
      return walkerResult.relatedElmFilePathsUntilError;
    case "ElmJsonReadAsJsonError":
    case "ElmJsonDecodeError":
      return new Set(
        mapNonEmptyArray(
          outputState.inputs,
          (inputPath) => inputPath.realpath.absolutePath
        )
      );
  }
}
function ensureAllRelatedElmFilePaths(elmJsonPath, outputState) {
  if (outputState.allRelatedElmFilePaths.size === 0) {
    const result = getAllRelatedElmFilePaths(elmJsonPath, outputState.inputs);
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      result,
      outputState
    );
  }
}

// src/Help.ts
var elmWatchJson2 = bold("elm-watch.json");
function render(loggerConfig) {
  const symbolLegend = loggerConfig.fancy ? `
${bold("Symbol legend:")}

${join(
    Object.values(EMOJI).map(({ emoji, description }) => {
      const indent = "    ";
      return `${indent}${emojiWidthFix({
        emoji,
        column: indent.length + 3,
        isTTY: loggerConfig.isTTY
      })} ${description}`;
    }),
    "\n"
  )}
` : "";
  return `
${bold("elm-watch init")}
    Create a minimal ${elmWatchJson2} in the current directory.

${bold("elm-watch make [--debug|--optimize] [target names...]")}
    Compile Elm code into JS. Similar to ${bold("elm make")}.

${bold("elm-watch hot [target names...]")}
    Recompile whenever your Elm files change,
    and reload the compiled JS in the browser.
    You can switch to ${bold("--debug")} and ${bold("--optimize")}
    mode in the browser.

By default all targets in the closest ${elmWatchJson2} are built.
Pass ${bold("target names")} to only build some. Names are matched by substring!

${dim("---")}
${symbolLegend}
${bold("Durations legend:")}

    ${bold("Q")} queued for elm make
    ${bold("E")} elm make
    ${bold("T")} elm make (typecheck only)
    ${bold("W")} find all related Elm file paths
    ${bold("I")} inject hot reloading code
    ${bold("R")} queued for postprocess
    ${bold("P")} postprocess
    ${bold(loggerConfig.fancy ? "\xA6" : "/")} next is run in parallel

${dim("---")}

${bold("Environment variables:")}
    ${bold(NO_COLOR)}
        Disable colored output

${bold("Documentation:")}
    https://github.com/lydell/elm-watch#readme

${bold("Version:")}
    1.0.2
`.trim();
}

// src/Init.ts
var fs8 = require("fs");
var elmWatchJson3 = bold("elm-watch.json");
function init(cwd, logger, args) {
  if (isNonEmptyArray(args)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${bold("elm-watch init")} takes no arguments.`
    );
    return 1;
  }
  const elmWatchJsonPath = {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: absolutePathFromString(cwd.path, "elm-watch.json")
  };
  if (fs8.existsSync(elmWatchJsonPath.theElmWatchJsonPath.absolutePath)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${elmWatchJson3} already exists in the current directory!`
    );
    return 1;
  }
  const example2 = example(cwd, elmWatchJsonPath, {
    elmFiles: [],
    output: void 0
  });
  try {
    fs8.writeFileSync(
      elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
      example2
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    logger.writeToStderrMakesALotOfSenseHere(
      `Failed to write ${elmWatchJson3}:

${error.message}`
    );
    return 1;
  }
  logger.write(
    `
Created a minimal ${elmWatchJson3} in the current directory to get you started.
Go check it out!

Documentation: https://github.com/lydell/elm-watch#elm-watchjson
  `.trim()
  );
  return 0;
}

// src/CliArgs.ts
function parseArgs(runMode, args) {
  let debug = false;
  let optimize = false;
  const unknownFlags2 = [];
  const targetsSubstrings = [];
  for (const arg of args) {
    switch (arg.theArg) {
      case "--debug":
        debug = true;
        break;
      case "--optimize":
        optimize = true;
        break;
      default:
        if (arg.theArg.startsWith("-")) {
          unknownFlags2.push(arg);
        } else {
          targetsSubstrings.push(arg.theArg);
        }
    }
  }
  switch (runMode) {
    case "hot":
      if (debug || optimize) {
        return { tag: "DebugOptimizeForHot" };
      }
      break;
    case "make":
      if (debug && optimize) {
        return { tag: "DebugOptimizeClash" };
      }
      break;
  }
  if (isNonEmptyArray(unknownFlags2)) {
    return {
      tag: "UnknownFlags",
      unknownFlags: unknownFlags2
    };
  }
  return {
    tag: "Success",
    compilationMode: debug ? "debug" : optimize ? "optimize" : "standard",
    targetsSubstrings
  };
}

// src/ElmWatchStuffJson.ts
var fs9 = require("fs");
var Decode6 = require("tiny-decoders");
var CompilationMode = Decode6.stringUnion({
  debug: null,
  optimize: null
});
var Target2 = Decode6.fieldsAuto({
  compilationMode: CompilationMode
});
var ElmWatchStuffJson = Decode6.fieldsAuto({
  port: Port,
  targets: Decode6.record(Target2)
});
function readAndParse2(elmWatchStuffJsonPath) {
  let json = void 0;
  try {
    json = JSON.parse(
      fs9.readFileSync(
        elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
        "utf-8"
      )
    );
  } catch (unknownError) {
    const error = toError(unknownError);
    return error.code === "ENOENT" ? {
      tag: "NoElmWatchStuffJson",
      elmWatchStuffJsonPath
    } : {
      tag: "ElmWatchStuffJsonReadAsJsonError",
      error
    };
  }
  try {
    return {
      tag: "Parsed",
      elmWatchStuffJsonPath,
      elmWatchStuffJson: ElmWatchStuffJson(json)
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ElmWatchStuffJsonDecodeError",
      error
    };
  }
}

// src/Hot.ts
var chokidar = require("chokidar");
var fs10 = require("fs");
var path6 = require("path");
var Decode9 = require("tiny-decoders");
var import_url = require("url");

// client/WebSocketMessages.ts
var Decode8 = require("tiny-decoders");

// src/Types.ts
var Decode7 = require("tiny-decoders");
var CompilationMode2 = Decode7.stringUnion({
  debug: null,
  standard: null,
  optimize: null
});
function equalsInputPath(elmFile, inputPath) {
  return inputPath.theInputPath.absolutePath === elmFile.absolutePath || inputPath.realpath.absolutePath === elmFile.absolutePath;
}

// client/WebSocketMessages.ts
var FocusedTabAcknowledged = Decode8.fieldsAuto({
  tag: () => "FocusedTabAcknowledged"
});
var StatusChanged = Decode8.fieldsAuto({
  tag: () => "StatusChanged",
  status: Decode8.fieldsUnion("tag", {
    AlreadyUpToDate: Decode8.fieldsAuto({
      tag: () => "AlreadyUpToDate",
      compilationMode: CompilationMode2
    }),
    Busy: Decode8.fieldsAuto({
      tag: () => "Busy",
      compilationMode: CompilationMode2
    }),
    CompileError: Decode8.fieldsAuto({
      tag: () => "CompileError",
      compilationMode: CompilationMode2
    }),
    ClientError: Decode8.fieldsAuto({
      tag: () => "ClientError",
      message: Decode8.string
    })
  })
});
var SuccessfullyCompiled = Decode8.fieldsAuto({
  tag: () => "SuccessfullyCompiled",
  code: Decode8.string,
  elmCompiledTimestamp: Decode8.number,
  compilationMode: CompilationMode2
});
var SuccessfullyCompiledButRecordFieldsChanged = Decode8.fieldsAuto({
  tag: () => "SuccessfullyCompiledButRecordFieldsChanged"
});
var WebSocketToClientMessage = Decode8.fieldsUnion("tag", {
  FocusedTabAcknowledged,
  StatusChanged,
  SuccessfullyCompiled,
  SuccessfullyCompiledButRecordFieldsChanged
});
var WebSocketToServerMessage = Decode8.fieldsUnion("tag", {
  ChangedCompilationMode: Decode8.fieldsAuto({
    tag: () => "ChangedCompilationMode",
    compilationMode: CompilationMode2
  }),
  FocusedTab: Decode8.fieldsAuto({
    tag: () => "FocusedTab"
  })
});
function encodeWebSocketToClientMessage(message) {
  switch (message.tag) {
    case "SuccessfullyCompiled": {
      const shortMessage = { ...message, code: "" };
      return `//${JSON.stringify(shortMessage)}
${message.code}`;
    }
    default:
      return JSON.stringify(message);
  }
}

// src/HashMap.ts
var util4 = require("util");
var _a2;
var HashMap = class {
  constructor(entries) {
    this.map = /* @__PURE__ */ new Map();
    this[_a2] = "HashMap";
    if (entries !== void 0 && entries !== null) {
      for (const [key, value] of entries) {
        this.map.set(hash2(key), value);
      }
    }
  }
  get size() {
    return this.map.size;
  }
  has(key) {
    return this.map.has(hash2(key));
  }
  get(key) {
    return this.map.get(hash2(key));
  }
  set(key, value) {
    this.map.set(hash2(key), value);
    return this;
  }
  delete(key) {
    return this.map.delete(hash2(key));
  }
  clear() {
    this.map.clear();
  }
  forEach(callback) {
    return callback;
  }
  *keys() {
    for (const key of this.map.keys()) {
      yield JSON.parse(key);
    }
  }
  values() {
    return this.map.values();
  }
  *entries() {
    for (const [key, value] of this.map.entries()) {
      yield [JSON.parse(key), value];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [(_a2 = Symbol.toStringTag, util4.inspect.custom)]() {
    return new Map(this);
  }
};
function hash2(value) {
  return JSON.stringify(
    Object.fromEntries(
      Object.entries(value).sort(([a], [b]) => a < b ? -1 : 1)
    )
  );
}

// src/Project.ts
var os3 = require("os");
var OutputState = class {
  constructor(inputs, compilationMode, getNow) {
    this.getNow = getNow;
    this._status = { tag: "NotWrittenToDisk" };
    this._durations = [];
    this._lastStartTimestamp = 0;
    this.allRelatedElmFilePaths = /* @__PURE__ */ new Set();
    this.recordFields = void 0;
    this.dirty = true;
    this.inputs = inputs;
    this.compilationMode = compilationMode;
  }
  flushDurations() {
    const durations = this._durations.slice();
    this._durations.length = 0;
    return durations;
  }
  get status() {
    return this._status;
  }
  setStatus(status) {
    const lastStartTimestamp = this._lastStartTimestamp;
    this._lastStartTimestamp = this.getNow().getTime();
    switch (this._status.tag) {
      case "ElmMake":
        this._durations.push({
          tag: "ElmMake",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        if (this._status.injectDurationMs !== -1) {
          this._durations.push({
            tag: "Inject",
            durationMs: this._status.injectDurationMs
          });
        }
        break;
      case "ElmMakeTypecheckOnly":
        this._durations.push({
          tag: "ElmMakeTypecheckOnly",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        break;
      case "Postprocess":
      case "QueuedForElmMake":
      case "QueuedForPostprocess":
        this._durations.push({
          tag: this._status.tag,
          durationMs: this._lastStartTimestamp - lastStartTimestamp
        });
        break;
      default:
        this._durations.length = 0;
    }
    this._status = status;
  }
};
function initProject({
  env,
  getNow,
  compilationMode,
  elmWatchJsonPath,
  config,
  enabledTargetsSubstrings,
  elmWatchStuffDir,
  elmWatchStuffJsonPath,
  elmWatchStuffJson: elmWatchStuffJson2
}) {
  const disabledOutputs = new HashSet();
  const elmJsonsErrors = [];
  const elmJsons = new HashMap();
  const potentialOutputDuplicates = new HashMap();
  for (const [index, [targetName, target]] of Object.entries(
    config.targets
  ).entries()) {
    const outputPath = {
      tag: "OutputPath",
      theOutputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath),
        target.output
      ),
      temporaryOutputPath: absolutePathFromString(
        elmWatchStuffDir.theElmWatchStuffDir,
        `${index}.js`
      ),
      originalString: target.output,
      targetName
    };
    const previousOutput = potentialOutputDuplicates.get(
      outputPath.theOutputPath
    );
    if (previousOutput === void 0) {
      potentialOutputDuplicates.set(outputPath.theOutputPath, [
        outputPath.originalString
      ]);
    } else {
      previousOutput.push(outputPath.originalString);
    }
    if (enabledTargetsSubstrings.some(
      (substring) => targetName.includes(substring)
    )) {
      const resolveElmJsonResult = resolveElmJson(
        elmWatchJsonPath,
        target.inputs
      );
      const persisted = elmWatchStuffJson2?.targets[targetName];
      const thisCompilationMode = persisted === void 0 ? compilationMode : persisted.compilationMode;
      switch (resolveElmJsonResult.tag) {
        case "Success": {
          const previous = elmJsons.get(resolveElmJsonResult.elmJsonPath) ?? new HashMap();
          previous.set(
            outputPath,
            new OutputState(
              resolveElmJsonResult.inputs,
              thisCompilationMode,
              getNow
            )
          );
          elmJsons.set(resolveElmJsonResult.elmJsonPath, previous);
          break;
        }
        default:
          elmJsonsErrors.push({
            outputPath,
            compilationMode: thisCompilationMode,
            error: resolveElmJsonResult
          });
          break;
      }
    } else {
      disabledOutputs.add(outputPath);
    }
  }
  const duplicateOutputs2 = Array.from(potentialOutputDuplicates).filter(([, outputPaths]) => outputPaths.length >= 2).map(([absolutePath, originalOutputPathStrings]) => ({
    originalOutputPathStrings,
    absolutePath
  }));
  if (isNonEmptyArray(duplicateOutputs2)) {
    return {
      tag: "DuplicateOutputs",
      duplicates: duplicateOutputs2
    };
  }
  const paths = mapNonEmptyArray(
    [
      elmWatchJsonPath.theElmWatchJsonPath,
      ...Array.from(
        elmJsons.keys(),
        (elmJsonPath) => elmJsonPath.theElmJsonPath
      )
    ],
    (absolutePath) => absoluteDirname(absolutePath)
  );
  const watchRoot = longestCommonAncestorPath(paths);
  if (watchRoot === void 0) {
    return { tag: "NoCommonRoot", paths };
  }
  const maxParallel = silentlyReadIntEnvValue(
    env[__ELM_WATCH_MAX_PARALLEL],
    os3.cpus().length
  );
  const postprocess = config.postprocess === void 0 ? { tag: "NoPostprocess" } : { tag: "Postprocess", postprocessArray: config.postprocess };
  return {
    tag: "Project",
    project: {
      watchRoot,
      elmWatchJsonPath,
      elmWatchStuffJsonPath,
      disabledOutputs,
      elmJsonsErrors,
      elmJsons,
      maxParallel,
      postprocess
    }
  };
}
function resolveElmJson(elmWatchJsonPath, inputStrings) {
  const inputs = [];
  const inputsNotFound2 = [];
  const inputsFailedToResolve2 = [];
  const resolved = new HashMap();
  for (const inputString of inputStrings) {
    const uncheckedInputPath = {
      tag: "UncheckedInputPath",
      theUncheckedInputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath.theElmWatchJsonPath),
        inputString
      ),
      originalString: inputString
    };
    let realpath;
    try {
      realpath = absoluteRealpath(uncheckedInputPath.theUncheckedInputPath);
    } catch (unknownError) {
      const error = toError(unknownError);
      if (error.code === "ENOENT" || error.code === "ENOTDIR") {
        inputsNotFound2.push(uncheckedInputPath);
      } else {
        inputsFailedToResolve2.push({ inputPath: uncheckedInputPath, error });
      }
      continue;
    }
    const inputPath = {
      tag: "InputPath",
      theInputPath: uncheckedInputPath.theUncheckedInputPath,
      originalString: inputString,
      realpath
    };
    const previous = resolved.get(realpath);
    if (previous === void 0) {
      resolved.set(realpath, [inputPath]);
    } else {
      previous.push(inputPath);
    }
    inputs.push(inputPath);
  }
  if (isNonEmptyArray(inputsNotFound2)) {
    return {
      tag: "InputsNotFound",
      inputsNotFound: inputsNotFound2
    };
  }
  if (isNonEmptyArray(inputsFailedToResolve2)) {
    return {
      tag: "InputsFailedToResolve",
      inputsFailedToResolve: inputsFailedToResolve2
    };
  }
  const duplicateInputs2 = Array.from(resolved).filter(([, inputPaths]) => inputPaths.length >= 2).map(([resolvedPath, inputPaths]) => ({
    resolved: resolvedPath,
    inputs: inputPaths
  }));
  if (isNonEmptyArray(duplicateInputs2)) {
    return {
      tag: "DuplicateInputs",
      duplicates: duplicateInputs2
    };
  }
  const elmJsonNotFound2 = [];
  const elmJsonPaths = [];
  for (const inputPath of inputs) {
    const elmJsonPathRaw = findClosest(
      "elm.json",
      absoluteDirname(inputPath.theInputPath)
    );
    if (elmJsonPathRaw === void 0) {
      elmJsonNotFound2.push(inputPath);
    } else {
      elmJsonPaths.push({
        inputPath,
        elmJsonPath: { tag: "ElmJsonPath", theElmJsonPath: elmJsonPathRaw }
      });
    }
  }
  if (isNonEmptyArray(elmJsonNotFound2)) {
    return {
      tag: "ElmJsonNotFound",
      elmJsonNotFound: elmJsonNotFound2,
      foundElmJsonPaths: elmJsonPaths
    };
  }
  const elmJsonPathsSet = new HashSet(
    elmJsonPaths.map(({ elmJsonPath }) => elmJsonPath)
  );
  const uniqueElmJsonPath = getSetSingleton(elmJsonPathsSet);
  if (uniqueElmJsonPath === void 0) {
    return {
      tag: "NonUniqueElmJsonPaths",
      nonUniqueElmJsonPaths: elmJsonPaths
    };
  }
  return {
    tag: "Success",
    elmJsonPath: uniqueElmJsonPath,
    inputs
  };
}
function getFlatOutputs(project) {
  return Array.from(project.elmJsons.values()).flatMap(
    (outputs) => Array.from(outputs, ([outputPath, outputState]) => ({
      outputPath,
      outputState
    }))
  );
}
function projectToDebug(project) {
  return {
    watchRoot: project.watchRoot.absolutePath,
    elmWatchJson: project.elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
    elmWatchStuffJson: project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
    maxParallel: project.maxParallel,
    postprocess: project.postprocess,
    enabledTargets: Array.from(project.elmJsons.entries()).flatMap(
      ([elmJsonPath, outputs]) => Array.from(outputs.entries(), ([outputPath, outputState]) => ({
        ...outputPathToDebug(outputPath),
        compilationMode: outputState.compilationMode,
        elmJson: elmJsonPath.theElmJsonPath.absolutePath,
        inputs: outputState.inputs.map(inputPathToDebug)
      }))
    ),
    disabledTargets: Array.from(project.disabledOutputs, outputPathToDebug),
    erroredTargets: project.elmJsonsErrors.map(
      ({ outputPath, compilationMode, error }) => ({
        error: error.tag,
        ...outputPathToDebug(outputPath),
        compilationMode
      })
    )
  };
}
function outputPathToDebug(outputPath) {
  return {
    targetName: outputPath.targetName,
    output: outputPath.theOutputPath.absolutePath,
    temporaryOutput: outputPath.temporaryOutputPath.absolutePath,
    originalString: outputPath.originalString
  };
}
function inputPathToDebug(inputPath) {
  return {
    input: inputPath.theInputPath.absolutePath,
    realpath: inputPath.realpath.absolutePath,
    originalString: inputPath.originalString
  };
}

// src/TeaProgram.ts
async function runTeaProgram(options) {
  return new Promise((resolve3, reject) => {
    const [initialModel, initialCmds] = options.init;
    let model = initialModel;
    const msgQueue = [];
    let killed = false;
    const dispatch = (dispatchedMsg) => {
      if (killed) {
        return;
      }
      const alreadyRunning = msgQueue.length > 0;
      msgQueue.push(dispatchedMsg);
      if (alreadyRunning) {
        return;
      }
      for (const msg of msgQueue) {
        const [newModel, cmds] = options.update(msg, model);
        model = newModel;
        runCmds(cmds);
      }
      msgQueue.length = 0;
    };
    const runCmds = (cmds) => {
      for (const cmd of cmds) {
        options.runCmd(
          cmd,
          mutable,
          dispatch,
          (result) => {
            cmds.length = 0;
            killed = true;
            resolve3(result);
          },
          (error) => {
            cmds.length = 0;
            killed = true;
            reject(error);
          }
        );
        if (killed) {
          break;
        }
      }
    };
    const mutable = options.initMutable(
      dispatch,
      (result) => {
        killed = true;
        resolve3(result);
      },
      (error) => {
        killed = true;
        reject(error);
      }
    );
    runCmds(initialCmds);
  });
}

// src/WebSocketServer.ts
var util5 = require("util");
var import_ws = require("ws");
var WebSocketServer = class {
  constructor(portChoice) {
    this.msgQueue = [];
    this.dispatchToQueue = (msg) => {
      this.msgQueue.push(msg);
    };
    this.dispatch = this.dispatchToQueue;
    this.webSocketServer = new import_ws.Server({
      port: portChoice.tag === "NoPort" ? 0 : portChoice.port.thePort
    });
    this.port = { tag: "Port", thePort: 0 };
    this.listening = new Promise((resolve3) => {
      this.webSocketServer.once("listening", () => {
        const { port } = this.webSocketServer.address();
        this.port.thePort = port;
        resolve3();
      });
    });
    this.webSocketServer.on("connection", (webSocket, request) => {
      webSocket[util5.inspect.custom] = (_depth, options) => options.stylize("WebSocket", "special");
      this.dispatch({
        tag: "WebSocketConnected",
        webSocket,
        urlString: request.url ?? "/"
      });
      webSocket.on("message", (data) => {
        this.dispatch({
          tag: "WebSocketMessageReceived",
          webSocket,
          data
        });
      });
      webSocket.on("close", () => {
        this.dispatch({ tag: "WebSocketClosed", webSocket });
      });
      webSocket.on("error", (error) => {
        this.dispatch({
          tag: "WebSocketServerError",
          error: { tag: "OtherError", error }
        });
      });
    });
    this.webSocketServer.on("error", (error) => {
      this.dispatch({
        tag: "WebSocketServerError",
        error: error.code === "EADDRINUSE" ? { tag: "PortConflict", portChoice, error } : { tag: "OtherError", error }
      });
    });
  }
  setDispatch(dispatch) {
    this.dispatch = dispatch;
    for (const msg of this.msgQueue) {
      dispatch(msg);
    }
  }
  unsetDispatch() {
    this.dispatch = this.dispatchToQueue;
  }
  async close() {
    return new Promise((resolve3, reject) => {
      this.webSocketServer.close((error) => {
        if (error === void 0) {
          resolve3();
        } else {
          reject(error);
        }
      });
      for (const webSocket of this.webSocketServer.clients) {
        webSocket.close();
      }
    });
  }
};

// src/Hot.ts
async function run(env, logger, getNow, restartReasons, postprocessWorkerPool, webSocketState, project, portChoice, hotKillManager) {
  const exitOnError = __ELM_WATCH_EXIT_ON_ERROR in env;
  const result = await runTeaProgram({
    initMutable: initMutable(
      env,
      getNow,
      postprocessWorkerPool,
      webSocketState,
      project,
      portChoice,
      hotKillManager
    ),
    init: init2(getNow(), restartReasons, project.elmJsonsErrors),
    update: (msg, model) => {
      const [newModel, cmds] = update(
        logger.config,
        project,
        exitOnError,
        msg,
        model
      );
      const allCmds = [
        ...cmds,
        newModel.latestEvents.length > model.latestEvents.length ? {
          tag: "SleepBeforeNextAction",
          sleepMs: getNextActionSleepMs(newModel.latestEvents)
        } : { tag: "NoCmd" }
      ];
      logger.debug(msg.tag, msg, newModel, allCmds);
      return [newModel, allCmds];
    },
    runCmd: runCmd(env, logger, getNow, exitOnError)
  });
  delete hotKillManager.kill;
  return result;
}
async function watchElmWatchJsonOnce(getNow, elmWatchJsonPath) {
  return new Promise((resolve3, reject) => {
    const watcher = chokidar.watch(
      elmWatchJsonPath.theElmWatchJsonPath.absolutePath,
      {
        ignoreInitial: true,
        disableGlobbing: true
      }
    );
    watcherOnAll(watcher, reject, (eventName, absolutePathString) => {
      const event = {
        tag: "WatcherEvent",
        date: getNow(),
        eventName,
        file: {
          tag: "AbsolutePath",
          absolutePath: absolutePathString
        }
      };
      watcher.close().then(() => {
        resolve3(event);
      }).catch(reject);
    });
  });
}
var initMutable = (env, getNow, postprocessWorkerPool, webSocketState, project, portChoice, hotKillManager) => (dispatch, resolvePromise, rejectPromise) => {
  const workerLimitTimeoutMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS],
    1e4
  );
  const watcher = chokidar.watch(project.watchRoot.absolutePath, {
    ignoreInitial: true,
    ignored: /\/(elm-stuff|node_modules)\//,
    disableGlobbing: true
  });
  watcherOnAll(
    watcher,
    (error) => {
      closeAll(mutable).then(() => {
        resolvePromise({
          tag: "ExitOnHandledFatalError",
          errorTemplate: watcherError(error)
        });
      }).catch(rejectPromise);
    },
    (eventName, absolutePathString) => {
      dispatch({
        tag: "GotWatcherEvent",
        date: getNow(),
        eventName,
        absolutePathString
      });
    }
  );
  const {
    webSocketServer = new WebSocketServer(portChoice),
    webSocketConnections = []
  } = webSocketState ?? {};
  const mutable = {
    watcher,
    postprocessWorkerPool,
    webSocketServer,
    webSocketConnections,
    lastWebSocketCloseTimestamp: void 0,
    workerLimitTimeoutMs,
    project,
    lastInfoMessage: void 0,
    watcherTimeoutId: void 0,
    elmWatchStuffJsonWriteError: void 0,
    killInstallDependencies: void 0
  };
  webSocketServer.setDispatch((msg) => {
    onWebSocketServerMsg(
      getNow(),
      mutable,
      dispatch,
      resolvePromise,
      rejectPromise,
      msg
    );
  });
  postprocessWorkerPool.setCalculateMax(
    () => mutable.lastWebSocketCloseTimestamp !== void 0 && getNow().getTime() >= mutable.lastWebSocketCloseTimestamp + workerLimitTimeoutMs ? Math.max(1, makePrioritizedOutputs(mutable.webSocketConnections).size) : Infinity
  );
  webSocketServer.listening.then(() => {
    writeElmWatchStuffJson(mutable);
  }).catch(rejectPromise);
  hotKillManager.kill = async () => {
    dispatch({ tag: "ExitRequested", date: getNow() });
    try {
      if (mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies();
      }
      await Promise.all(
        getFlatOutputs(project).map(
          ({ outputState }) => "kill" in outputState.status ? outputState.status.kill() : Promise.resolve()
        )
      );
      await closeAll(mutable);
    } catch (unknownError) {
      const error = toError(unknownError);
      rejectPromise(toError(error));
    }
    delete hotKillManager.kill;
    resolvePromise({ tag: "ExitOnIdle" });
  };
  return mutable;
};
function writeElmWatchStuffJson(mutable) {
  const json = {
    port: mutable.webSocketServer.port.thePort,
    targets: Object.fromEntries(
      getFlatOutputs(mutable.project).flatMap(
        ({ outputPath, outputState }) => outputState.compilationMode === "standard" ? [] : [
          [
            outputPath.targetName,
            { compilationMode: outputState.compilationMode }
          ]
        ]
      )
    )
  };
  try {
    fs10.mkdirSync(
      absoluteDirname(
        mutable.project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath
      ).absolutePath,
      { recursive: true }
    );
    fs10.writeFileSync(
      mutable.project.elmWatchStuffJsonPath.theElmWatchStuffJsonPath.absolutePath,
      `${JSON.stringify(json, null, 4)}
`
    );
    mutable.elmWatchStuffJsonWriteError = void 0;
  } catch (unknownError) {
    const error = toError(unknownError);
    mutable.elmWatchStuffJsonWriteError = error;
  }
}
function watcherOnAll(watcher, onError, onSuccess) {
  watcher.on("all", (chokidarEventName, absolutePathString) => {
    switch (chokidarEventName) {
      case "add":
      case "addDir":
        onSuccess("added", absolutePathString);
        return;
      case "unlink":
      case "unlinkDir":
        onSuccess("removed", absolutePathString);
        return;
      case "change":
        onSuccess("changed", absolutePathString);
        return;
    }
  });
  watcher.on("error", onError);
}
var init2 = (now, restartReasons, elmJsonsErrors) => [
  {
    nextAction: { tag: "NoAction" },
    hotState: {
      tag: "Dependencies",
      start: now
    },
    latestEvents: restartReasons
  },
  [
    { tag: "ClearScreen" },
    { tag: "InstallDependencies" },
    ...elmJsonsErrors.map(
      ({ outputPath, compilationMode }) => ({
        tag: "WebSocketSendToOutput",
        outputPath,
        message: {
          tag: "StatusChanged",
          status: {
            tag: "CompileError",
            compilationMode
          }
        }
      })
    )
  ]
];
function update(loggerConfig, project, exitOnError, msg, model) {
  switch (msg.tag) {
    case "GotWatcherEvent": {
      const result = onWatcherEvent(
        msg.date,
        project,
        msg.eventName,
        msg.absolutePathString,
        model.nextAction
      );
      if (result === void 0) {
        return [model, []];
      }
      const [updatedNextAction, latestEvent, cmds] = result;
      return [
        {
          ...model,
          nextAction: updatedNextAction,
          latestEvents: [...model.latestEvents, latestEvent]
        },
        cmds
      ];
    }
    case "ExitRequested":
      if (model.hotState.tag !== "Idle") {
        return [
          model,
          [
            {
              tag: "Throw",
              error: new Error(
                `Got ExitRequested. Expected hotState to be Idle but it is: ${model.hotState.tag}`
              )
            }
          ]
        ];
      }
      switch (model.nextAction.tag) {
        case "Restart":
        case "Compile":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `Got ExitRequested. Expected nextAction to be NoAction but it is: ${model.nextAction.tag}`
                )
              }
            ]
          ];
        case "NoAction":
          return runNextAction(msg.date, project, model);
      }
    case "SleepBeforeNextActionDone": {
      const [newModel, cmds] = runNextAction(msg.date, project, model);
      return [
        {
          ...newModel,
          nextAction: { tag: "NoAction" }
        },
        cmds
      ];
    }
    case "CompilationPartDone": {
      const includeInterrupted = model.nextAction.tag !== "Compile";
      const outputActions = getOutputActions({
        project,
        runMode: "hot",
        includeInterrupted,
        prioritizedOutputs: msg.prioritizedOutputs
      });
      switch (model.hotState.tag) {
        case "Dependencies":
        case "Idle":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while compiling!`
                )
              }
            ]
          ];
        case "Compiling": {
          const duration = msg.date.getTime() - model.hotState.start.getTime();
          const cmd = handleOutputActionResultToCmd(
            msg.handleOutputActionResult
          );
          if (isNonEmptyArray(outputActions.actions)) {
            return [
              model,
              [
                cmd,
                {
                  tag: "CompileAllOutputsAsNeeded",
                  mode: "ContinueCompilation",
                  includeInterrupted
                }
              ]
            ];
          }
          if (outputActions.numExecuting > 0 || outputActions.numInterrupted > 0) {
            return [model, [cmd]];
          }
          const errors = extractErrors(project);
          return [
            { ...model, hotState: { tag: "Idle" }, latestEvents: [] },
            [
              cmd,
              isNonEmptyArray(errors) ? { tag: "PrintCompileErrors", errors } : { tag: "NoCmd" },
              { tag: "HandleElmWatchStuffJsonWriteError" },
              {
                tag: "LogInfoMessageWithTimeline",
                message: compileFinishedMessage(loggerConfig, duration),
                events: model.latestEvents
              },
              isNonEmptyArray(errors) && exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }
            ]
          ];
        }
        case "Restarting":
          return outputActions.numExecuting === 0 ? [model, [{ tag: "Restart", restartReasons: model.latestEvents }]] : [model, []];
      }
    }
    case "InstallDependenciesDone":
      switch (model.hotState.tag) {
        case "Dependencies": {
          switch (msg.installResult.tag) {
            case "Error":
              return [
                { ...model, hotState: { tag: "Idle" } },
                [
                  exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }
                ]
              ];
            case "Killed":
              return [{ ...model, hotState: { tag: "Idle" } }, []];
            case "Success": {
              return [
                {
                  ...model,
                  hotState: {
                    tag: "Compiling",
                    start: model.hotState.start
                  }
                },
                [
                  {
                    tag: "CompileAllOutputsAsNeeded",
                    mode: "AfterInstallDependencies",
                    includeInterrupted: true
                  }
                ]
              ];
            }
          }
        }
        case "Restarting":
          return [
            model,
            [{ tag: "Restart", restartReasons: model.latestEvents }]
          ];
        case "Idle":
        case "Compiling":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while installing dependencies!`
                )
              }
            ]
          ];
      }
    case "WebSocketClosed":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WebSocketClosed",
              date: msg.date,
              outputPath: msg.outputPath
            }
          ]
        },
        []
      ];
    case "WebSocketConnected": {
      const result = msg.parseWebSocketConnectRequestUrlResult;
      switch (result.tag) {
        case "Success": {
          const [newModel, latestEvent, cmds] = onWebSocketConnected(
            msg.date,
            model,
            result.outputPath,
            result.outputState,
            result.elmCompiledTimestamp
          );
          return [
            {
              ...newModel,
              latestEvents: [...newModel.latestEvents, latestEvent]
            },
            cmds
          ];
        }
        default:
          return [
            {
              ...model,
              latestEvents: [
                ...model.latestEvents,
                {
                  tag: "WebSocketConnectedWithErrors",
                  date: msg.date
                }
              ]
            },
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketConnectRequestUrlErrorToString(result)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WebSocketMessageReceived": {
      const result = parseWebSocketToServerMessage(msg.data);
      switch (result.tag) {
        case "Success":
          return onWebSocketToServerMessage(
            model,
            msg.date,
            msg.output,
            msg.webSocket,
            result.message
          );
        case "DecodeError":
          return [
            model,
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketDecodeError(result.error)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WorkerLimitTimeoutPassed":
      return [model, [{ tag: "LimitWorkers" }]];
    case "WorkersLimited":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WorkersLimitedAfterWebSocketClosed",
              date: msg.date,
              numTerminatedWorkers: msg.numTerminatedWorkers
            }
          ]
        },
        []
      ];
  }
}
function onWatcherEvent(now, project, eventName, absolutePathString, nextAction) {
  if (absolutePathString.endsWith(".elm")) {
    return onElmFileWatcherEvent(
      project,
      makeWatcherEvent(eventName, absolutePathString, now),
      nextAction
    );
  }
  const basename2 = path6.basename(absolutePathString);
  switch (basename2) {
    case "elm-watch.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        case "changed":
        case "removed":
          if (absolutePathString === project.elmWatchJsonPath.theElmWatchJsonPath.absolutePath) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePathString, now),
              project
            );
          }
          return void 0;
      }
    case "elm.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        case "changed":
        case "removed":
          if (Array.from(project.elmJsons).some(
            ([elmJsonPath]) => absolutePathString === elmJsonPath.theElmJsonPath.absolutePath
          ) || isElmJsonFileRelatedToElmJsonsErrors(
            absolutePathString,
            project.elmJsonsErrors
          )) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePathString, now),
              project
            );
          }
          return void 0;
      }
    case "elm-stuff":
      switch (eventName) {
        case "removed":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePathString, now),
            project
          );
        default:
          return void 0;
      }
    default:
      switch (project.postprocess.tag) {
        case "Postprocess": {
          const [commandName, scriptPathString] = project.postprocess.postprocessArray;
          if (commandName === ELM_WATCH_NODE && scriptPathString !== void 0) {
            const scriptPath = absolutePathFromString(
              absoluteDirname(project.elmWatchJsonPath.theElmWatchJsonPath),
              scriptPathString
            );
            if (absolutePathString === scriptPath.absolutePath) {
              return [
                compileNextAction(nextAction),
                {
                  ...makeWatcherEvent(eventName, absolutePathString, now),
                  affectsAnyTarget: true
                },
                [
                  {
                    tag: "MarkAsDirty",
                    outputs: getFlatOutputs(project),
                    killInstallDependencies: false
                  },
                  { tag: "RestartWorkers" }
                ]
              ];
            }
          }
          return void 0;
        }
        case "NoPostprocess":
          return void 0;
      }
  }
}
function onElmFileWatcherEvent(project, event, nextAction) {
  const elmFile = event.file;
  if (isElmFileRelatedToElmJsonsErrors(elmFile, project.elmJsonsErrors)) {
    return makeRestartNextAction(event, project);
  }
  const dirtyOutputs = [];
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    for (const [outputPath, outputState] of outputs) {
      if (event.eventName === "removed") {
        for (const inputPath of outputState.inputs) {
          if (equalsInputPath(elmFile, inputPath)) {
            return makeRestartNextAction(event, project);
          }
        }
      }
      ensureAllRelatedElmFilePaths(elmJsonPath, outputState);
      if (outputState.allRelatedElmFilePaths.has(elmFile.absolutePath)) {
        dirtyOutputs.push({ outputPath, outputState });
      }
    }
  }
  return isNonEmptyArray(dirtyOutputs) ? [
    compileNextAction(nextAction),
    { ...event, affectsAnyTarget: true },
    [
      {
        tag: "MarkAsDirty",
        outputs: dirtyOutputs,
        killInstallDependencies: false
      }
    ]
  ] : [nextAction, { ...event, affectsAnyTarget: false }, []];
}
function runNextAction(start, project, model) {
  switch (model.nextAction.tag) {
    case "Restart":
      switch (model.hotState.tag) {
        case "Idle":
          return [
            { ...model, hotState: { tag: "Restarting" } },
            [
              { tag: "ClearScreen" },
              { tag: "Restart", restartReasons: model.latestEvents }
            ]
          ];
        case "Dependencies":
        case "Compiling": {
          return [{ ...model, hotState: { tag: "Restarting" } }, []];
        }
        case "Restarting":
          return [model, []];
      }
    case "Compile":
      switch (model.hotState.tag) {
        case "Idle": {
          return [
            {
              ...model,
              hotState: { tag: "Compiling", start }
            },
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "AfterIdle",
                includeInterrupted: true
              }
            ]
          ];
        }
        case "Compiling":
          return [
            model,
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "ContinueCompilation",
                includeInterrupted: true
              }
            ]
          ];
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
    case "NoAction":
      switch (model.hotState.tag) {
        case "Idle":
          return isNonEmptyArray(model.latestEvents) ? [
            { ...model, latestEvents: [] },
            [
              {
                tag: "LogInfoMessageWithTimeline",
                message: printEventsMessage(
                  model.latestEvents,
                  project.disabledOutputs
                ),
                events: model.latestEvents
              }
            ]
          ] : [model, []];
        case "Compiling":
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
  }
}
var runCmd = (env, logger, getNow, exitOnError) => (cmd, mutable, dispatch, resolvePromise, rejectPromise) => {
  switch (cmd.tag) {
    case "ChangeCompilationMode":
      cmd.outputState.compilationMode = cmd.compilationMode;
      writeElmWatchStuffJson(mutable);
      return;
    case "ClearScreen":
      logger.clearScreen();
      mutable.lastInfoMessage = void 0;
      return;
    case "CompileAllOutputsAsNeeded": {
      const outputActions = getOutputActions({
        project: mutable.project,
        runMode: "hot",
        includeInterrupted: cmd.includeInterrupted,
        prioritizedOutputs: makePrioritizedOutputs(
          mutable.webSocketConnections
        )
      });
      switch (cmd.mode) {
        case "AfterInstallDependencies":
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "AfterIdle":
          logger.clearScreen();
          mutable.lastInfoMessage = void 0;
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "ContinueCompilation":
          break;
      }
      if (isNonEmptyArray(outputActions.actions)) {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: {
              tag: "hot",
              webSocketPort: mutable.webSocketServer.port
            },
            elmWatchJsonPath: mutable.project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: mutable.project.postprocess,
            postprocessWorkerPool: mutable.postprocessWorkerPool
          }).then((handleOutputActionResult) => {
            dispatch({
              tag: "CompilationPartDone",
              date: getNow(),
              prioritizedOutputs: makePrioritizedOutputs(
                mutable.webSocketConnections
              ),
              handleOutputActionResult
            });
          }).catch(rejectPromise);
        }
      } else if (outputActions.numExecuting === 0) {
        dispatch({
          tag: "CompilationPartDone",
          date: getNow(),
          prioritizedOutputs: makePrioritizedOutputs(
            mutable.webSocketConnections
          ),
          handleOutputActionResult: { tag: "Nothing" }
        });
      }
      return;
    }
    case "HandleElmWatchStuffJsonWriteError":
      if (mutable.elmWatchStuffJsonWriteError !== void 0) {
        writeElmWatchStuffJson(mutable);
        if (mutable.elmWatchStuffJsonWriteError !== void 0) {
          logger.write("");
          logger.errorTemplate(
            elmWatchStuffJsonWriteError(
              mutable.project.elmWatchStuffJsonPath,
              mutable.elmWatchStuffJsonWriteError
            )
          );
          if (exitOnError) {
            closeAll(mutable).then(() => {
              resolvePromise({ tag: "ExitOnIdle" });
            }).catch(rejectPromise);
          }
        }
      }
      return;
    case "InstallDependencies": {
      mutable.webSocketServer.listening.then(() => {
        const { promise, kill } = installDependencies(
          env,
          logger,
          getNow,
          mutable.project
        );
        mutable.killInstallDependencies = () => {
          kill();
          mutable.killInstallDependencies = void 0;
        };
        return promise;
      }).finally(() => {
        mutable.killInstallDependencies = void 0;
      }).then((installResult) => {
        dispatch({
          tag: "InstallDependenciesDone",
          date: getNow(),
          installResult
        });
      }).catch(rejectPromise);
      return;
    }
    case "LimitWorkers":
      mutable.postprocessWorkerPool.limit().then((numTerminatedWorkers) => {
        if (numTerminatedWorkers > 0) {
          dispatch({
            tag: "WorkersLimited",
            date: getNow(),
            numTerminatedWorkers
          });
        }
      }).catch(rejectPromise);
      return;
    case "LogInfoMessageWithTimeline": {
      if (mutable.lastInfoMessage !== void 0) {
        logger.moveCursor(0, -mutable.lastInfoMessage.split("\n").length);
        logger.clearScreenDown();
      }
      const fullMessage = infoMessageWithTimeline({
        loggerConfig: logger.config,
        date: getNow(),
        mutable,
        message: cmd.message,
        events: filterLatestEvents(cmd.events),
        hasErrors: isNonEmptyArray(extractErrors(mutable.project))
      });
      logger.write(fullMessage);
      logger.clearScreenDown();
      mutable.lastInfoMessage = fullMessage;
      if (__ELM_WATCH_EXIT_ON_WORKER_LIMIT in env && cmd.events.some(
        (event) => event.tag === "WorkersLimitedAfterWebSocketClosed"
      )) {
        closeAll(mutable).then(() => {
          resolvePromise({ tag: "ExitOnIdle" });
        }).catch(rejectPromise);
      }
      return;
    }
    case "MarkAsDirty":
      if (cmd.killInstallDependencies && mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies();
      }
      for (const { outputPath, outputState } of cmd.outputs) {
        outputState.dirty = true;
        if ("kill" in outputState.status) {
          Promise.resolve(outputState.status.kill()).catch(rejectPromise);
        }
        webSocketSendToOutput(
          outputPath,
          {
            tag: "StatusChanged",
            status: {
              tag: "Busy",
              compilationMode: outputState.compilationMode
            }
          },
          mutable.webSocketConnections
        );
      }
      return;
    case "NoCmd":
      return;
    case "PrintCompileErrors":
      printErrors(logger, cmd.errors);
      return;
    case "Restart": {
      const elmWatchJsonChanged = cmd.restartReasons.some((event) => {
        switch (event.tag) {
          case "WatcherEvent":
            return path6.basename(event.file.absolutePath) === "elm-watch.json";
          default:
            return false;
        }
      });
      mutable.webSocketServer.unsetDispatch();
      Promise.all([
        mutable.watcher.close(),
        elmWatchJsonChanged ? mutable.webSocketServer.close() : void 0,
        elmWatchJsonChanged ? mutable.postprocessWorkerPool.terminate() : void 0
      ]).then(() => {
        resolvePromise({
          tag: "Restart",
          restartReasons: cmd.restartReasons,
          postprocessWorkerPool: mutable.postprocessWorkerPool,
          webSocketState: elmWatchJsonChanged ? void 0 : {
            webSocketServer: mutable.webSocketServer,
            webSocketConnections: mutable.webSocketConnections
          }
        });
      }).catch(rejectPromise);
      return;
    }
    case "RestartWorkers":
      mutable.postprocessWorkerPool.terminate().then(() => {
        mutable.postprocessWorkerPool.getOrCreateAvailableWorker();
      }).catch(rejectPromise);
      return;
    case "ExitOnIdle":
      closeAll(mutable).then(() => {
        resolvePromise({ tag: "ExitOnIdle" });
      }).catch(rejectPromise);
      return;
    case "SleepBeforeNextAction":
      if (mutable.watcherTimeoutId !== void 0) {
        clearTimeout(mutable.watcherTimeoutId);
      }
      mutable.watcherTimeoutId = setTimeout(() => {
        mutable.watcherTimeoutId = void 0;
        dispatch({ tag: "SleepBeforeNextActionDone", date: getNow() });
      }, cmd.sleepMs);
      return;
    case "Throw":
      rejectPromise(cmd.error);
      return;
    case "WebSocketSend":
      webSocketSend(cmd.webSocket, cmd.message);
      return;
    case "WebSocketSendToOutput":
      webSocketSendToOutput(
        cmd.outputPath,
        cmd.message,
        mutable.webSocketConnections
      );
      return;
    case "WebSocketUpdatePriority":
      for (const webSocketConnection of mutable.webSocketConnections) {
        if (webSocketConnection.webSocket === cmd.webSocket) {
          webSocketConnection.priority = getNow().getTime();
        }
      }
      return;
  }
};
function onWebSocketServerMsg(now, mutable, dispatch, resolvePromise, rejectPromise, msg) {
  switch (msg.tag) {
    case "WebSocketConnected": {
      const result = parseWebSocketConnectRequestUrl(
        mutable.project,
        msg.urlString
      );
      const webSocketConnection = {
        webSocket: msg.webSocket,
        outputPath: result.tag === "Success" ? result.outputPath : { tag: "OutputPathError" },
        priority: now.getTime()
      };
      mutable.webSocketConnections.push(webSocketConnection);
      dispatch({
        tag: "WebSocketConnected",
        date: now,
        parseWebSocketConnectRequestUrlResult: result,
        webSocket: msg.webSocket
      });
      return;
    }
    case "WebSocketClosed": {
      const removedConnection = mutable.webSocketConnections.find(
        (connection) => connection.webSocket === msg.webSocket
      );
      mutable.webSocketConnections = mutable.webSocketConnections.filter(
        (connection) => connection.webSocket !== msg.webSocket
      );
      mutable.lastWebSocketCloseTimestamp = now.getTime();
      setTimeout(() => {
        dispatch({ tag: "WorkerLimitTimeoutPassed" });
      }, mutable.workerLimitTimeoutMs);
      dispatch({
        tag: "WebSocketClosed",
        date: now,
        outputPath: removedConnection === void 0 ? { tag: "OutputPathError" } : removedConnection.outputPath
      });
      return;
    }
    case "WebSocketMessageReceived": {
      const webSocketConnection = mutable.webSocketConnections.find(
        ({ webSocket }) => webSocket === msg.webSocket
      );
      if (webSocketConnection === void 0) {
        rejectPromise(
          new Error(
            `No web socket connection found for web socket message ${JSON.stringify(
              msg.tag
            )}`
          )
        );
        return;
      }
      const flatOutputs = getFlatOutputs(mutable.project);
      const output = flatOutputs.find(
        ({ outputPath }) => webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)
      );
      dispatch({
        tag: "WebSocketMessageReceived",
        date: now,
        output: output === void 0 ? { tag: "OutputPathError" } : { tag: "Output", ...output },
        webSocket: msg.webSocket,
        data: msg.data
      });
      return;
    }
    case "WebSocketServerError":
      switch (msg.error.tag) {
        case "PortConflict": {
          const { portChoice } = msg.error;
          closeAll(mutable).then(() => {
            resolvePromise({
              tag: "ExitOnHandledFatalError",
              errorTemplate: portChoiceError(
                mutable.project,
                portChoice,
                msg.error.error
              )
            });
          }).catch(rejectPromise);
          return;
        }
        case "OtherError":
          rejectPromise(msg.error.error);
          return;
      }
  }
}
function portChoiceError(project, portChoice, error) {
  switch (portChoice.tag) {
    case "NoPort":
      return portConflictForNoPort(error);
    case "PersistedPort":
      return portConflictForPersistedPort(
        project.elmWatchStuffJsonPath,
        portChoice.port
      );
    case "PortFromConfig":
      return portConflictForPortFromConfig(
        project.elmWatchJsonPath,
        portChoice.port
      );
  }
}
function handleOutputActionResultToCmd(handleOutputActionResult) {
  switch (handleOutputActionResult.tag) {
    case "CompileError":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: {
          tag: "StatusChanged",
          status: {
            tag: "CompileError",
            compilationMode: handleOutputActionResult.compilationMode
          }
        }
      };
    case "FullyCompiledJS":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: {
          tag: "SuccessfullyCompiled",
          code: handleOutputActionResult.code.toString("utf8"),
          elmCompiledTimestamp: handleOutputActionResult.elmCompiledTimestamp,
          compilationMode: handleOutputActionResult.compilationMode
        }
      };
    case "FullyCompiledJSButRecordFieldsChanged":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: { tag: "SuccessfullyCompiledButRecordFieldsChanged" }
      };
    case "Nothing":
      return { tag: "NoCmd" };
  }
}
async function closeAll(mutable) {
  if (mutable.watcherTimeoutId !== void 0) {
    clearTimeout(mutable.watcherTimeoutId);
  }
  await Promise.all([
    mutable.watcher.close(),
    mutable.webSocketServer.close(),
    mutable.postprocessWorkerPool.terminate()
  ]);
}
function makePrioritizedOutputs(webSocketConnections) {
  const map = new HashMap();
  for (const { outputPath, priority } of webSocketConnections) {
    if (outputPath.tag !== "OutputPathError") {
      const previous = map.get(outputPath) ?? 0;
      map.set(outputPath, Math.max(priority, previous));
    }
  }
  return map;
}
function makeWatcherEvent(eventName, absolutePathString, date) {
  return {
    tag: "WatcherEvent",
    date,
    eventName,
    file: {
      tag: "AbsolutePath",
      absolutePath: absolutePathString
    }
  };
}
function makeRestartNextAction(event, project) {
  return [
    { tag: "Restart" },
    { ...event, affectsAnyTarget: true },
    [
      {
        tag: "MarkAsDirty",
        outputs: getFlatOutputs(project),
        killInstallDependencies: true
      }
    ]
  ];
}
function isElmFileRelatedToElmJsonsErrors(elmFile, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
        return error.duplicates.some(
          ({ inputs, resolved }) => resolved.absolutePath === elmFile.absolutePath || inputs.some((inputPath) => equalsInputPath(elmFile, inputPath))
        );
      case "ElmJsonNotFound":
        return error.elmJsonNotFound.some(
          (inputPath) => equalsInputPath(elmFile, inputPath)
        ) || error.foundElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
      case "InputsFailedToResolve":
        return error.inputsFailedToResolve.some(
          ({ inputPath }) => inputPath.theUncheckedInputPath.absolutePath === elmFile.absolutePath
        );
      case "InputsNotFound":
        return error.inputsNotFound.some(
          (inputPath) => inputPath.theUncheckedInputPath.absolutePath === elmFile.absolutePath
        );
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
    }
  });
}
function isElmJsonFileRelatedToElmJsonsErrors(absoluteElmJsonFilePath, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
      case "InputsFailedToResolve":
      case "InputsNotFound":
        return false;
      case "ElmJsonNotFound":
        return error.foundElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath.theElmJsonPath.absolutePath === absoluteElmJsonFilePath
        );
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath.theElmJsonPath.absolutePath === absoluteElmJsonFilePath
        );
    }
  });
}
function webSocketConnectionIsForOutputPath(webSocketConnection, outputPath) {
  switch (webSocketConnection.outputPath.tag) {
    case "OutputPathError":
      return false;
    case "OutputPath":
      return webSocketConnection.outputPath.theOutputPath.absolutePath === outputPath.theOutputPath.absolutePath;
  }
}
var WebSocketConnectedParams = Decode9.fieldsAuto(
  {
    elmWatchVersion: Decode9.string,
    targetName: Decode9.string,
    elmCompiledTimestamp: Decode9.chain(Decode9.string, (string6) => {
      const number4 = Number(string6);
      if (Number.isFinite(number4)) {
        return number4;
      }
      throw new Decode9.DecoderError({
        message: "Expected a number",
        value: string6
      });
    })
  },
  { exact: "throw" }
);
function parseWebSocketConnectRequestUrl(project, urlString) {
  if (!urlString.startsWith("/?")) {
    return {
      tag: "BadUrl",
      expectedStart: "/?",
      actualUrlString: urlString
    };
  }
  const params = new import_url.URLSearchParams(urlString.slice(2));
  let webSocketConnectedParams;
  try {
    webSocketConnectedParams = WebSocketConnectedParams(
      Object.fromEntries(params)
    );
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return {
      tag: "ParamsDecodeError",
      error,
      actualUrlString: urlString
    };
  }
  if (webSocketConnectedParams.elmWatchVersion !== "1.0.2") {
    return {
      tag: "WrongVersion",
      expectedVersion: "1.0.2",
      actualVersion: webSocketConnectedParams.elmWatchVersion
    };
  }
  const flatOutputs = getFlatOutputs(project);
  const { targetName } = webSocketConnectedParams;
  const match = flatOutputs.find(
    ({ outputPath }) => outputPath.targetName === targetName
  );
  if (match === void 0) {
    const enabledOutputs = flatOutputs.map(({ outputPath }) => outputPath);
    const disabledOutputs = Array.from(project.disabledOutputs);
    const disabledMatch = disabledOutputs.find(
      (outputPath) => outputPath.targetName === targetName
    );
    return disabledMatch === void 0 ? {
      tag: "TargetNotFound",
      targetName,
      enabledOutputs,
      disabledOutputs
    } : {
      tag: "TargetDisabled",
      targetName,
      enabledOutputs,
      disabledOutputs
    };
  }
  return {
    tag: "Success",
    outputPath: match.outputPath,
    outputState: match.outputState,
    elmCompiledTimestamp: webSocketConnectedParams.elmCompiledTimestamp
  };
}
function webSocketConnectRequestUrlErrorToString(error) {
  switch (error.tag) {
    case "BadUrl":
      return webSocketBadUrl(error.expectedStart, error.actualUrlString);
    case "ParamsDecodeError":
      return webSocketParamsDecodeError(
        error.error,
        error.actualUrlString
      );
    case "WrongVersion":
      return webSocketWrongVersion(
        error.expectedVersion,
        error.actualVersion
      );
    case "TargetNotFound":
      return webSocketTargetNotFound(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
    case "TargetDisabled":
      return webSocketTargetDisabled(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
  }
}
function parseWebSocketToServerMessage(data) {
  const stringData = typeof data === "string" ? data : Array.isArray(data) ? Buffer.concat(data).toString("utf8") : data instanceof ArrayBuffer ? new TextDecoder("utf8").decode(data) : data.toString("utf8");
  try {
    return {
      tag: "Success",
      message: WebSocketToServerMessage(JSON.parse(stringData))
    };
  } catch (unknownError) {
    const error = toJsonError(unknownError);
    return { tag: "DecodeError", error };
  }
}
function onWebSocketConnected(date, model, outputPath, outputState, elmCompiledTimestamp) {
  const event = {
    tag: "WebSocketConnectedNeedingCompilation",
    date,
    outputPath
  };
  const recompileNeeded = () => {
    const [newModel, cmds] = onWebSocketRecompileNeeded(
      model,
      outputPath,
      outputState
    );
    return [newModel, event, cmds];
  };
  switch (model.hotState.tag) {
    case "Restarting":
    case "Dependencies":
      return [model, event, []];
    case "Idle":
    case "Compiling":
      switch (outputState.status.tag) {
        case "Success":
          return outputState.status.elmCompiledTimestamp === elmCompiledTimestamp ? [
            model,
            {
              tag: "WebSocketConnectedNeedingNoAction",
              date,
              outputPath
            },
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "AlreadyUpToDate",
                    compilationMode: outputState.compilationMode
                  }
                }
              }
            ]
          ] : recompileNeeded();
        case "NotWrittenToDisk":
        case "ElmMakeTypecheckOnly":
          return recompileNeeded();
        case "ElmMake":
        case "Postprocess":
        case "Interrupted":
        case "QueuedForElmMake":
        case "QueuedForPostprocess":
          switch (model.hotState.tag) {
            case "Idle":
              return recompileNeeded();
            case "Compiling":
              return [model, event, []];
          }
        default: {
          const _ = outputState.status;
          return [
            model,
            event,
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "CompileError",
                    compilationMode: outputState.compilationMode
                  }
                }
              }
            ]
          ];
        }
      }
  }
}
function onChangedCompilationMode(model, outputPath, outputState) {
  switch (model.hotState.tag) {
    case "Restarting":
    case "Dependencies":
      return [model, []];
    case "Idle":
    case "Compiling":
      return onWebSocketRecompileNeeded(model, outputPath, outputState);
  }
}
function onWebSocketRecompileNeeded(model, outputPath, outputState) {
  switch (model.nextAction.tag) {
    case "Restart":
      return [model, []];
    case "Compile":
    case "NoAction":
      return [
        {
          ...model,
          nextAction: { tag: "Compile" }
        },
        [
          {
            tag: "MarkAsDirty",
            outputs: [{ outputPath, outputState }],
            killInstallDependencies: false
          }
        ]
      ];
  }
}
function compileNextAction(nextAction) {
  switch (nextAction.tag) {
    case "Restart":
    case "Compile":
      return nextAction;
    case "NoAction":
      return { tag: "Compile" };
  }
}
function onWebSocketToServerMessage(model, date, output, webSocket, message) {
  switch (message.tag) {
    case "ChangedCompilationMode": {
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const [newModel, cmds] = onChangedCompilationMode(
            model,
            output.outputPath,
            output.outputState
          );
          return [
            {
              ...newModel,
              latestEvents: [
                ...newModel.latestEvents,
                {
                  tag: "WebSocketChangedCompilationMode",
                  date,
                  outputPath: output.outputPath,
                  compilationMode: message.compilationMode
                }
              ]
            },
            [
              {
                tag: "ChangeCompilationMode",
                outputState: output.outputState,
                compilationMode: message.compilationMode
              },
              ...cmds
            ]
          ];
        }
      }
    }
    case "FocusedTab":
      return [
        model,
        [
          { tag: "WebSocketUpdatePriority", webSocket },
          {
            tag: "WebSocketSend",
            webSocket,
            message: { tag: "FocusedTabAcknowledged" }
          }
        ]
      ];
  }
}
function webSocketSend(webSocket, message) {
  webSocket.send(encodeWebSocketToClientMessage(message));
}
function webSocketSendToOutput(outputPath, message, webSocketConnections) {
  for (const webSocketConnection of webSocketConnections) {
    if (webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)) {
      webSocketSend(webSocketConnection.webSocket, message);
    }
  }
}
function getNextActionSleepMs(events) {
  return Math.max(0, ...events.map(getLatestEventSleepMs));
}
function getLatestEventSleepMs(event) {
  switch (event.tag) {
    case "WatcherEvent":
      return 10;
    case "WebSocketClosed":
    case "WebSocketConnectedNeedingCompilation":
    case "WebSocketConnectedNeedingNoAction":
    case "WebSocketConnectedWithErrors":
    case "WorkersLimitedAfterWebSocketClosed":
      return 100;
    case "WebSocketChangedCompilationMode":
      return 10;
  }
}
function filterLatestEvents(events) {
  const filtered = events.filter(
    (event) => !(event.tag === "WatcherEvent" && !event.affectsAnyTarget)
  );
  return isNonEmptyArray(filtered) ? filtered : events;
}
function infoMessageWithTimeline({
  loggerConfig,
  date,
  mutable,
  message,
  events,
  hasErrors
}) {
  return join(
    [
      "",
      printStats(loggerConfig, mutable),
      "",
      printTimeline(loggerConfig, events),
      printMessageWithTimeAndEmoji({
        loggerConfig,
        emojiName: hasErrors ? "Error" : "Success",
        date,
        dateHighlight: bold,
        message
      })
    ].flatMap((part) => part === void 0 ? [] : part),
    "\n"
  );
}
function printMessageWithTimeAndEmoji({
  loggerConfig,
  emojiName,
  date,
  dateHighlight: highlightTime,
  message
}) {
  const newDate = loggerConfig.mockedTimings ? new Date("2022-02-05T13:10:05Z") : date;
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: `${highlightTime(formatTime(newDate))} ${message}`
  });
}
function printStats(loggerConfig, mutable) {
  const numWorkers = mutable.postprocessWorkerPool.getSize();
  return join(
    [
      numWorkers > 0 ? `${dim(`${ELM_WATCH_NODE} workers:`)} ${numWorkers}` : void 0,
      `${dim("web socket connections:")} ${mutable.webSocketConnections.length} ${dim(`(ws://0.0.0.0:${mutable.webSocketServer.port.thePort})`)}`
    ].flatMap(
      (part) => part === void 0 ? [] : printStatusLine({
        maxWidth: Infinity,
        fancy: loggerConfig.fancy,
        isTTY: loggerConfig.isTTY,
        emojiName: "Stats",
        string: part
      })
    ),
    "\n"
  );
}
function printTimeline(loggerConfig, events) {
  if (!isNonEmptyArray(events)) {
    return void 0;
  }
  const base = 2;
  if (events.length <= 2 * base + 1) {
    return dim(
      join(
        mapNonEmptyArray(events, (event) => printEvent(loggerConfig, event)),
        "\n"
      )
    );
  }
  const start = events.slice(0, base);
  const end = events.slice(-base);
  const numMoreEvents = events.length - 2 * base;
  return dim(
    join(
      [
        ...start.map((event) => printEvent(loggerConfig, event)),
        `${loggerConfig.fancy ? "   " : ""}(${numMoreEvents} more events)`,
        ...end.map((event) => printEvent(loggerConfig, event))
      ],
      "\n"
    )
  );
}
function printEvent(loggerConfig, event) {
  return printMessageWithTimeAndEmoji({
    loggerConfig,
    emojiName: "Information",
    date: event.date,
    dateHighlight: (string6) => string6,
    message: printEventMessage(event)
  });
}
function printEventMessage(event) {
  switch (event.tag) {
    case "WatcherEvent":
      return `${capitalize(event.eventName)} ${event.file.absolutePath}`;
    case "WebSocketClosed":
      return `Web socket disconnected for: ${event.outputPath.tag === "OutputPath" ? event.outputPath.targetName : "(no matching target)"}`;
    case "WebSocketConnectedNeedingCompilation":
      return `Web socket connected needing compilation of: ${event.outputPath.targetName}`;
    case "WebSocketConnectedNeedingNoAction":
      return `Web socket connected for: ${event.outputPath.targetName}`;
    case "WebSocketConnectedWithErrors":
      return `Web socket connected with errors (see the browser for details)`;
    case "WebSocketChangedCompilationMode":
      return `Changed compilation mode to ${JSON.stringify(
        event.compilationMode
      )} of: ${event.outputPath.targetName}`;
    case "WorkersLimitedAfterWebSocketClosed":
      return `Terminated ${event.numTerminatedWorkers} superfluous ${event.numTerminatedWorkers === 1 ? "worker" : "workers"}`;
  }
}
function compileFinishedMessage(loggerConfig, duration) {
  return `Compilation finished in ${bold(
    printDurationMs(
      loggerConfig.mockedTimings ? 123 : duration
    ).trim()
  )}.`;
}
function printEventsMessage(events, disabledOutputs) {
  const what1 = events.length === 1 ? "file is" : "files are";
  const what2 = disabledOutputs.size > 0 ? "any of the enabled targets" : "any target";
  return events.every(
    (event) => event.tag === "WatcherEvent" && !event.affectsAnyTarget
  ) ? `FYI: The above Elm ${what1} not imported by ${what2}. Nothing to do!` : "Everything up to date.";
}

// src/Make.ts
async function run2(env, logger, getNow, project, postprocessWorkerPool) {
  const startTimestamp = getNow().getTime();
  const installResult = await installDependencies(
    env,
    logger,
    getNow,
    project
  ).promise;
  switch (installResult.tag) {
    case "Error":
    case "Killed":
      return { tag: "Error" };
    case "Success":
      break;
  }
  const initialOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  printStatusLinesForElmJsonsErrors(logger, project);
  if (isNonEmptyArray(initialOutputActions.actions) && !isNonEmptyArray(project.elmJsonsErrors)) {
    printSpaceForOutputs(logger, "make", initialOutputActions);
    await new Promise((resolve3, reject) => {
      const cycle = (outputActions) => {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: { tag: "make" },
            elmWatchJsonPath: project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: project.postprocess,
            postprocessWorkerPool
          }).then(() => {
            const nextOutputActions = getNextOutputActions(project);
            if (isNonEmptyArray(nextOutputActions.actions)) {
              cycle(nextOutputActions);
            } else if (nextOutputActions.numExecuting === 0) {
              resolve3();
            }
          }).catch(reject);
        }
      };
      cycle(initialOutputActions);
    });
  }
  const numWorkers = postprocessWorkerPool.getSize();
  await postprocessWorkerPool.terminate();
  const errors = extractErrors(project);
  const failed = isNonEmptyArray(errors);
  if (failed) {
    printErrors(logger, errors);
  }
  const duration = getNow().getTime() - startTimestamp;
  logger.write("");
  logger.write(
    compileFinishedMessage2({
      loggerConfig: logger.config,
      duration,
      numWorkers,
      hasErrors: failed
    })
  );
  return failed ? { tag: "Error" } : { tag: "Success" };
}
function getNextOutputActions(project) {
  const nextOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  return nextOutputActions.numErrors > 0 ? {
    ...nextOutputActions,
    actions: nextOutputActions.actions.filter(
      (action2) => action2.tag !== "NeedsPostprocess"
    )
  } : nextOutputActions;
}
function compileFinishedMessage2({
  loggerConfig,
  duration,
  numWorkers,
  hasErrors
}) {
  const workersString = numWorkers > 0 ? dim(
    ` (using ${numWorkers} ${ELM_WATCH_NODE} ${numWorkers === 1 ? "worker" : "workers"}).`
  ) : ".";
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName: hasErrors ? "Error" : "Success",
    string: `Compilation finished in ${bold(
      printDurationMs(
        loggerConfig.mockedTimings ? 123 : duration
      ).trim()
    )}${workersString}`
  });
}

// src/Run.ts
async function run3(cwd, env, logger, getNow, runMode, args, restartReasons, postprocessWorkerPool, webSocketState, hotKillManager) {
  const parseResult = findReadAndParse(cwd);
  switch (parseResult.tag) {
    case "ReadAsJsonError":
      logger.errorTemplate(
        readElmWatchJsonAsJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "DecodeError":
      logger.errorTemplate(
        decodeElmWatchJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "ElmWatchJsonNotFound":
      logger.errorTemplate(elmWatchJsonNotFound(cwd, args));
      return { tag: "Exit", exitCode: 1 };
    case "Parsed": {
      const parseArgsResult = parseArgs(runMode, args);
      switch (parseArgsResult.tag) {
        case "UnknownFlags":
          logger.errorTemplate(
            unknownFlags(
              cwd,
              parseResult.elmWatchJsonPath,
              runMode,
              args,
              parseArgsResult.unknownFlags
            )
          );
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeForHot":
          logger.errorTemplate(debugOptimizeForHot());
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeClash":
          logger.errorTemplate(debugOptimizeClash());
          return { tag: "Exit", exitCode: 1 };
        case "Success": {
          const { config } = parseResult;
          const knownTargets = Object.keys(
            config.targets
          );
          const unknownTargetsSubstrings2 = parseArgsResult.targetsSubstrings.filter(
            (substring) => !knownTargets.some(
              (targetName) => targetName.includes(substring)
            )
          );
          if (isNonEmptyArray(unknownTargetsSubstrings2)) {
            logger.errorTemplate(
              unknownTargetsSubstrings(
                parseResult.elmWatchJsonPath,
                knownTargets,
                unknownTargetsSubstrings2
              )
            );
            return { tag: "Exit", exitCode: 1 };
          }
          const elmWatchStuffDir = {
            tag: "ElmWatchStuffDir",
            theElmWatchStuffDir: absolutePathFromString(
              absoluteDirname(parseResult.elmWatchJsonPath.theElmWatchJsonPath),
              "elm-stuff",
              "elm-watch"
            )
          };
          const elmWatchStuffJsonPath = {
            tag: "ElmWatchStuffJsonPath",
            theElmWatchStuffJsonPath: absolutePathFromString(
              elmWatchStuffDir.theElmWatchStuffDir,
              "stuff.json"
            )
          };
          const elmWatchStuffJsonParseResult = runMode === "hot" ? readAndParse2(elmWatchStuffJsonPath) : void 0;
          switch (elmWatchStuffJsonParseResult?.tag) {
            case "ElmWatchStuffJsonReadAsJsonError":
              logger.errorTemplate(
                readElmWatchStuffJsonAsJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.error
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case "ElmWatchStuffJsonDecodeError":
              logger.errorTemplate(
                decodeElmWatchStuffJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.error
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case void 0:
            case "Parsed":
            case "NoElmWatchStuffJson": {
              const elmWatchStuffJson2 = elmWatchStuffJsonParseResult?.tag === "Parsed" ? elmWatchStuffJsonParseResult.elmWatchStuffJson : void 0;
              const initProjectResult = initProject({
                env,
                getNow,
                compilationMode: parseArgsResult.compilationMode,
                elmWatchJsonPath: parseResult.elmWatchJsonPath,
                config: parseResult.config,
                enabledTargetsSubstrings: isNonEmptyArray(
                  parseArgsResult.targetsSubstrings
                ) ? parseArgsResult.targetsSubstrings : knownTargets,
                elmWatchStuffDir,
                elmWatchStuffJsonPath,
                elmWatchStuffJson: elmWatchStuffJson2
              });
              switch (initProjectResult.tag) {
                case "DuplicateOutputs":
                  logger.errorTemplate(
                    duplicateOutputs(
                      parseResult.elmWatchJsonPath,
                      initProjectResult.duplicates
                    )
                  );
                  return handleElmWatchJsonError(
                    logger,
                    getNow,
                    runMode,
                    parseResult.elmWatchJsonPath,
                    postprocessWorkerPool
                  );
                case "NoCommonRoot":
                  logger.errorTemplate(
                    noCommonRoot(initProjectResult.paths)
                  );
                  return { tag: "Exit", exitCode: 1 };
                case "Project": {
                  const { project } = initProjectResult;
                  logger.debug("Project", projectToDebug(project));
                  switch (project.postprocess.tag) {
                    case "NoPostprocess":
                      break;
                    case "Postprocess":
                      if (project.postprocess.postprocessArray[0] === ELM_WATCH_NODE) {
                        postprocessWorkerPool.getOrCreateAvailableWorker();
                      }
                      break;
                  }
                  switch (runMode) {
                    case "make": {
                      const result = await run2(
                        env,
                        logger,
                        getNow,
                        project,
                        postprocessWorkerPool
                      );
                      switch (result.tag) {
                        case "Error":
                          return { tag: "Exit", exitCode: 1 };
                        case "Success":
                          return { tag: "Exit", exitCode: 0 };
                      }
                    }
                    case "hot": {
                      const result = await run(
                        env,
                        logger,
                        getNow,
                        restartReasons,
                        postprocessWorkerPool,
                        webSocketState,
                        project,
                        config.port !== void 0 ? { tag: "PortFromConfig", port: config.port } : elmWatchStuffJson2 !== void 0 ? {
                          tag: "PersistedPort",
                          port: elmWatchStuffJson2.port
                        } : { tag: "NoPort" },
                        hotKillManager
                      );
                      switch (result.tag) {
                        case "ExitOnHandledFatalError":
                          logger.errorTemplate(result.errorTemplate);
                          return { tag: "Exit", exitCode: 1 };
                        case "ExitOnIdle":
                          return { tag: "Exit", exitCode: 1 };
                        case "Restart":
                          return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
async function handleElmWatchJsonError(logger, getNow, runMode, elmWatchJsonPath, postprocessWorkerPool) {
  switch (runMode) {
    case "make":
      return { tag: "Exit", exitCode: 1 };
    case "hot": {
      logger.write("");
      printNumErrors(logger, 1);
      const elmWatchJsonEvent = await watchElmWatchJsonOnce(
        getNow,
        elmWatchJsonPath
      );
      logger.clearScreen();
      return {
        tag: "Restart",
        restartReasons: [{ ...elmWatchJsonEvent, affectsAnyTarget: true }],
        postprocessWorkerPool,
        webSocketState: void 0
      };
    }
  }
}

// src/index.ts
async function elmWatchCli(args, {
  cwd: cwdString,
  env,
  stdout,
  stderr,
  logDebug,
  hotKillManager = { kill: void 0 }
}) {
  const getNow = () => new Date();
  const logger = makeLogger({
    env,
    stdout,
    stderr,
    logDebug
  });
  const cwd = {
    tag: "Cwd",
    path: absolutePathFromString(
      { tag: "AbsolutePath", absolutePath: process.cwd() },
      cwdString
    )
  };
  const isHelp = args.some(
    (arg) => arg === "-h" || arg === "-help" || arg === "--help"
  );
  if (isHelp) {
    logger.write(render(logger.config));
    return 0;
  }
  const restArgs = args.slice(1).map((arg) => ({ tag: "CliArg", theArg: arg }));
  switch (args[0]) {
    case void 0:
    case "help":
      logger.write(render(logger.config));
      return 0;
    case "init":
      return init(cwd, logger, restArgs);
    case "make":
    case "hot": {
      const runMode = args[0];
      return new Promise((resolve3, reject) => {
        const doIt = async () => {
          let result;
          do {
            result = await run3(
              cwd,
              env,
              logger,
              getNow,
              runMode,
              restArgs,
              result === void 0 ? [] : result.restartReasons,
              result === void 0 ? new PostprocessWorkerPool(reject) : result.postprocessWorkerPool,
              result === void 0 ? void 0 : result.webSocketState,
              hotKillManager
            );
          } while (result.tag === "Restart");
          switch (result.tag) {
            case "Exit":
              return result.exitCode;
          }
        };
        doIt().then(resolve3).catch(reject);
      });
    }
    default:
      logger.write(`Unknown command: ${args[0]}`);
      return 1;
  }
}
if (require.main === module) {
  process.title = "elm-watch";
  elmWatchCli(process.argv.slice(2), {
    cwd: process.cwd(),
    env: process.env,
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    logDebug: (message) => process.stderr.write(`${message}
`)
  }).then((exitCode) => {
    process.exitCode = exitCode;
  }).catch((error) => {
    process.stderr.write(
      `Unexpected error:
${unknownErrorToString(error)}
`
    );
    process.exit(1);
  });
}